audio/aria/aria.c:		cd->gains[i] = (1ULL << (32 - cd->att - 1)) - 1;
audio/aria/aria.c:	cd->chan_cnt = chan_cnt;
audio/aria/aria.c:	cd->smpl_group_cnt = smpl_group_cnt;
audio/aria/aria.c:	cd->buff_size = ALIGN_UP(cd->chan_cnt * cd->smpl_group_cnt, 2);
audio/aria/aria.c:	cd->offset = (cd->chan_cnt * cd->smpl_group_cnt) & 1;
audio/aria/aria.c:	cd->att = att;
audio/aria/aria.c:	cd->data_addr = buffer_desc;
audio/aria/aria.c:	cd->data_ptr = cd->data_addr + cd->offset;
audio/aria/aria.c:	cd->data_end = cd->data_addr + cd->buff_size;
audio/aria/aria.c:	cd->buff_pos = 0;
audio/aria/aria.c:	memset((void *)cd->data_addr, 0, sizeof(int32_t) * cd->buff_size);
audio/aria/aria.c:	cd->gain_state = 0;
audio/aria/aria.c:	if (cd->att) {
audio/aria/aria.c:		aria_algo_calc_gain(cd, INDEX_TAB[cd->gain_state + 1], source, frames);
audio/aria/aria.c:		cd->aria_get_data(mod, sink, frames);
audio/aria/aria.c:		cir_buf_copy(cd->data_ptr, cd->data_addr, cd->data_end,
audio/aria/aria.c:		     cd->data_ptr, cd->data_addr, cd->data_end,
audio/aria/aria.c:	cd->data_ptr = cir_buf_wrap(cd->data_ptr + sample_size, cd->data_addr, cd->data_end);
audio/aria/aria.c:	rfree(cd->data_addr);
audio/aria/aria.c:	cd->aria_get_data = aria_algo_get_data_func(mod);
audio/aria/aria.c:		cd->gains[idx] = (1ULL << (32 - cd->att - 1)) - 1;
audio/aria/aria.c:	memset(cd->data_addr, 0, sizeof(int32_t) * cd->buff_size);
audio/aria/aria.c:	cd->gain_state = 0;
audio/aria/aria.c:	frames = MIN(frames, cd->smpl_group_cnt);
audio/aria/aria.c:		memcpy_s(&cd->att, sizeof(uint32_t), fragment, sizeof(uint32_t));
audio/aria/aria_generic.c:	uint32_t att = cd->att;
audio/aria/aria_generic.c:	cd->gains[gain_idx] = (int32_t)(gain >> (att + 1));
audio/aria/aria_generic.c:	int32_t gain_state_add_2 = cd->gain_state + 2;
audio/aria/aria_generic.c:	int32_t gain_state_add_3 = cd->gain_state + 3;
audio/aria/aria_generic.c:	int32_t gain_begin = cd->gains[INDEX_TAB[gain_state_add_2]];
audio/aria/aria_generic.c:	int32_t gain_end = cd->gains[INDEX_TAB[gain_state_add_3]];
audio/aria/aria_generic.c:	int32_t *in = cd->data_ptr;
audio/aria/aria_generic.c:	const int ch_n = cd->chan_cnt;
audio/aria/aria_generic.c:	const int shift = 31 - cd->att;
audio/aria/aria_generic.c:		if (cd->gains[INDEX_TAB[gain_state_add_2 + i]] < gain_begin)
audio/aria/aria_generic.c:			gain_begin = cd->gains[INDEX_TAB[gain_state_add_2 + i]];
audio/aria/aria_generic.c:		if (cd->gains[INDEX_TAB[gain_state_add_3 + i]] < gain_end)
audio/aria/aria_generic.c:			gain_end = cd->gains[INDEX_TAB[gain_state_add_3 + i]];
audio/aria/aria_generic.c:		m = cir_buf_samples_without_wrap_s32(cd->data_ptr, cd->data_end);
audio/aria/aria_generic.c:		in = cir_buf_wrap(in, cd->data_addr, cd->data_end);
audio/aria/aria_generic.c:	cd->gain_state = INDEX_TAB[cd->gain_state + 1];
audio/aria/aria_hifi3.c:	int32_t att = cd->att;
audio/aria/aria_hifi3.c:	cd->gains[gain_idx] = (int32_t)(gain >> (att + 1));
audio/aria/aria_hifi3.c:	int32_t gain_state_add_2 = cd->gain_state + 2;
audio/aria/aria_hifi3.c:	int32_t gain_state_add_3 = cd->gain_state + 3;
audio/aria/aria_hifi3.c:	int32_t gain_begin = cd->gains[INDEX_TAB[gain_state_add_2]];
audio/aria/aria_hifi3.c:	int32_t gain_end = cd->gains[INDEX_TAB[gain_state_add_3]];
audio/aria/aria_hifi3.c:	ae_int32x2 *in = (ae_int32x2 *)cd->data_ptr;
audio/aria/aria_hifi3.c:	const int ch_n = cd->chan_cnt;
audio/aria/aria_hifi3.c:	const int shift_bits = 31 - cd->att - 24;
audio/aria/aria_hifi3.c:		if (cd->gains[INDEX_TAB[gain_state_add_2 + i]] < gain_begin)
audio/aria/aria_hifi3.c:			gain_begin = cd->gains[INDEX_TAB[gain_state_add_2 + i]];
audio/aria/aria_hifi3.c:		if (cd->gains[INDEX_TAB[gain_state_add_3 + i]] < gain_end)
audio/aria/aria_hifi3.c:			gain_end = cd->gains[INDEX_TAB[gain_state_add_3 + i]];
audio/aria/aria_hifi3.c:		m = cir_buf_samples_without_wrap_s32(cd->data_ptr, cd->data_end);
audio/aria/aria_hifi3.c:		in = cir_buf_wrap(in, cd->data_addr, cd->data_end);
audio/aria/aria_hifi3.c:	cd->gain_state = INDEX_TAB[cd->gain_state + 1];
audio/aria/aria_hifi3.c:	int32_t gain_state_add_2 = cd->gain_state + 2;
audio/aria/aria_hifi3.c:	int32_t gain_state_add_3 = cd->gain_state + 3;
audio/aria/aria_hifi3.c:	int32_t gain_begin = cd->gains[INDEX_TAB[gain_state_add_2]];
audio/aria/aria_hifi3.c:	int32_t gain_end = cd->gains[INDEX_TAB[gain_state_add_3]];
audio/aria/aria_hifi3.c:	ae_int32x2 *in = (ae_int32x2 *)cd->data_ptr;
audio/aria/aria_hifi3.c:	const int ch_n = cd->chan_cnt;
audio/aria/aria_hifi3.c:	const int shift_bits = 31 - cd->att - 24;
audio/aria/aria_hifi3.c:		if (cd->gains[INDEX_TAB[gain_state_add_2 + i]] < gain_begin)
audio/aria/aria_hifi3.c:			gain_begin = cd->gains[INDEX_TAB[gain_state_add_2 + i]];
audio/aria/aria_hifi3.c:		if (cd->gains[INDEX_TAB[gain_state_add_3 + i]] < gain_end)
audio/aria/aria_hifi3.c:			gain_end = cd->gains[INDEX_TAB[gain_state_add_3 + i]];
audio/aria/aria_hifi3.c:		m = cir_buf_samples_without_wrap_s32(cd->data_ptr, cd->data_end);
audio/aria/aria_hifi3.c:		in = cir_buf_wrap(in, cd->data_addr, cd->data_end);
audio/aria/aria_hifi3.c:	cd->gain_state = INDEX_TAB[cd->gain_state + 1];
audio/aria/aria_hifi3.c:	if (cd->chan_cnt & 1)
audio/aria/aria_hifi5.c:	int32_t att = cd->att;
audio/aria/aria_hifi5.c:	cd->gains[gain_idx] = (int32_t)(gain >> (att + 1));
audio/aria/aria_hifi5.c:	int32_t gain_state_add_2 = cd->gain_state + 2;
audio/aria/aria_hifi5.c:	int32_t gain_state_add_3 = cd->gain_state + 3;
audio/aria/aria_hifi5.c:	int32_t gain_begin = cd->gains[index_tab[gain_state_add_2]];
audio/aria/aria_hifi5.c:	int32_t gain_end = cd->gains[index_tab[gain_state_add_3]];
audio/aria/aria_hifi5.c:	ae_int32 *in = (ae_int32 *)cd->data_ptr;
audio/aria/aria_hifi5.c:	const int ch_n = cd->chan_cnt;
audio/aria/aria_hifi5.c:	const int shift_bits = 31 - cd->att - 24;
audio/aria/aria_hifi5.c:		if (cd->gains[index_tab[gain_state_add_2 + i]] < gain_begin)
audio/aria/aria_hifi5.c:			gain_begin = cd->gains[index_tab[gain_state_add_2 + i]];
audio/aria/aria_hifi5.c:		if (cd->gains[index_tab[gain_state_add_3 + i]] < gain_end)
audio/aria/aria_hifi5.c:			gain_end = cd->gains[index_tab[gain_state_add_3 + i]];
audio/aria/aria_hifi5.c:	set_circular_buf0(cd->data_addr, cd->data_end);
audio/aria/aria_hifi5.c:	cd->gain_state = index_tab[cd->gain_state + 1];
audio/aria/aria_hifi5.c:	int32_t gain_state_add_2 = cd->gain_state + 2;
audio/aria/aria_hifi5.c:	int32_t gain_state_add_3 = cd->gain_state + 3;
audio/aria/aria_hifi5.c:	int32_t gain_begin = cd->gains[index_tab[gain_state_add_2]];
audio/aria/aria_hifi5.c:	int32_t gain_end = cd->gains[index_tab[gain_state_add_3]];
audio/aria/aria_hifi5.c:	ae_int32x2 *in = (ae_int32x2 *)cd->data_ptr;
audio/aria/aria_hifi5.c:	const int ch_n = cd->chan_cnt;
audio/aria/aria_hifi5.c:	const int shift_bits = 31 - cd->att - 24;
audio/aria/aria_hifi5.c:		if (cd->gains[index_tab[gain_state_add_2 + i]] < gain_begin)
audio/aria/aria_hifi5.c:			gain_begin = cd->gains[index_tab[gain_state_add_2 + i]];
audio/aria/aria_hifi5.c:		if (cd->gains[index_tab[gain_state_add_3 + i]] < gain_end)
audio/aria/aria_hifi5.c:			gain_end = cd->gains[index_tab[gain_state_add_3 + i]];
audio/aria/aria_hifi5.c:	set_circular_buf0(cd->data_addr, cd->data_end);
audio/aria/aria_hifi5.c:	cd->gain_state = index_tab[cd->gain_state + 1];
audio/aria/aria_hifi5.c:	if (cd->chan_cnt & 1)
audio/asrc/asrc.c:	buf = (int32_t *)cd->ibuf[0];
audio/asrc/asrc.c:	n = cd->source_frames * audio_stream_get_channels(source);
audio/asrc/asrc.c:			*buf++ = (*src++) << cd->data_shift;
audio/asrc/asrc.c:	in_frames = cd->source_frames;
audio/asrc/asrc.c:	out_frames = cd->sink_frames;
audio/asrc/asrc.c:	if (cd->mode == ASRC_OM_PUSH)
audio/asrc/asrc.c:		ret = asrc_process_push32(dev, cd->asrc_obj,
audio/asrc/asrc.c:					  (int32_t **)cd->ibuf, &in_frames,
audio/asrc/asrc.c:					  (int32_t **)cd->obuf, &out_frames,
audio/asrc/asrc.c:		ret = asrc_process_pull32(dev, cd->asrc_obj,
audio/asrc/asrc.c:					  (int32_t **)cd->ibuf, &in_frames,
audio/asrc/asrc.c:					  (int32_t **)cd->obuf, &out_frames,
audio/asrc/asrc.c:	buf = (int32_t *)cd->obuf[0];
audio/asrc/asrc.c:			*snk++ = (*buf++) >> cd->data_shift;
audio/asrc/asrc.c:	buf = (int16_t *)cd->ibuf[0];
audio/asrc/asrc.c:	n = cd->source_frames * audio_stream_get_channels(source);
audio/asrc/asrc.c:	in_frames = cd->source_frames;
audio/asrc/asrc.c:	out_frames = cd->sink_frames;
audio/asrc/asrc.c:	if (cd->mode == ASRC_OM_PUSH)
audio/asrc/asrc.c:		ret = asrc_process_push16(dev, cd->asrc_obj,
audio/asrc/asrc.c:					  (int16_t **)cd->ibuf, &in_frames,
audio/asrc/asrc.c:					  (int16_t **)cd->obuf, &out_frames,
audio/asrc/asrc.c:		ret = asrc_process_pull16(dev, cd->asrc_obj,
audio/asrc/asrc.c:					  (int16_t **)cd->ibuf, &in_frames,
audio/asrc/asrc.c:					  (int16_t **)cd->obuf, &out_frames,
audio/asrc/asrc.c:	buf = (int16_t *)cd->obuf[0];
audio/asrc/asrc.c:	memcpy_s(&cd->ipc_config, sizeof(cd->ipc_config), ipc_asrc, sizeof(cd->ipc_config));
audio/asrc/asrc.c:	cd->mode = asrc_get_operation_mode(ipc_asrc);
audio/asrc/asrc.c:	cd->track_drift = asrc_get_asynchronous_mode(ipc_asrc);
audio/asrc/asrc.c:	cd->skew = 0;
audio/asrc/asrc.c:	rfree(cd->buf);
audio/asrc/asrc.c:	asrc_release_buffers(cd->asrc_obj);
audio/asrc/asrc.c:	rfree(cd->asrc_obj);
audio/asrc/asrc.c:		if (asrc_get_source_rate(&cd->ipc_config) &&
audio/asrc/asrc.c:		    params->rate != asrc_get_source_rate(&cd->ipc_config)) {
audio/asrc/asrc.c:				 params->rate, asrc_get_source_rate(&cd->ipc_config));
audio/asrc/asrc.c:		if (asrc_get_sink_rate(&cd->ipc_config) &&
audio/asrc/asrc.c:		    params->rate != asrc_get_sink_rate(&cd->ipc_config)) {
audio/asrc/asrc.c:				 params->rate, asrc_get_sink_rate(&cd->ipc_config));
audio/asrc/asrc.c:	if (asrc_get_sink_rate(&cd->ipc_config))
audio/asrc/asrc.c:		audio_stream_set_rate(&sinkb->stream, asrc_get_sink_rate(&cd->ipc_config));
audio/asrc/asrc.c:	cd->source_rate = audio_stream_get_rate(&sourceb->stream);
audio/asrc/asrc.c:	cd->sink_rate = audio_stream_get_rate(&sinkb->stream);
audio/asrc/asrc.c:	if (!cd->sink_rate) {
audio/asrc/asrc.c:	component_set_nearest_period_frames(dev, cd->sink_rate);
audio/asrc/asrc.c:	cd->sink_frames = dev->frames;
audio/asrc/asrc.c:	cd->source_frames = ceil_divide(dev->frames * cd->source_rate,
audio/asrc/asrc.c:					cd->sink_rate);
audio/asrc/asrc.c:	cd->source_frames_max = cd->source_frames + 10;
audio/asrc/asrc.c:	cd->sink_frames_max = cd->sink_frames + 10;
audio/asrc/asrc.c:	cd->frames = MAX(cd->source_frames_max, cd->sink_frames_max);
audio/asrc/asrc.c:		  cd->source_rate, cd->sink_rate,
audio/asrc/asrc.c:		  cd->source_frames_max, cd->sink_frames_max);
audio/asrc/asrc.c:	cd->dai_dev = NULL;
audio/asrc/asrc.c:	if (cd->mode == ASRC_OM_PUSH) {
audio/asrc/asrc.c:	cd->dai_dev = dev;
audio/asrc/asrc.c:	if (cmd == COMP_TRIGGER_START && cd->track_drift) {
audio/asrc/asrc.c:			cd->track_drift = false;
audio/asrc/asrc.c:		cd->ts_count = 0;
audio/asrc/asrc.c:			cd->track_drift = false;
audio/asrc/asrc.c:	cd->source_format = audio_stream_get_frm_fmt(&sourceb->stream);
audio/asrc/asrc.c:							cd->source_frames);
audio/asrc/asrc.c:	cd->sink_format = audio_stream_get_frm_fmt(&sinkb->stream);
audio/asrc/asrc.c:						      cd->sink_frames);
audio/asrc/asrc.c:		cd->asrc_func = src_copy_s16;
audio/asrc/asrc.c:		cd->data_shift = 8;
audio/asrc/asrc.c:		cd->asrc_func = src_copy_s32;
audio/asrc/asrc.c:		cd->data_shift = 0;
audio/asrc/asrc.c:		cd->asrc_func = src_copy_s32;
audio/asrc/asrc.c:	cd->buf_size = (cd->source_frames_max + cd->sink_frames_max) *
audio/asrc/asrc.c:	cd->buf = rzalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM,
audio/asrc/asrc.c:			  cd->buf_size);
audio/asrc/asrc.c:	if (!cd->buf) {
audio/asrc/asrc.c:		cd->buf_size = 0;
audio/asrc/asrc.c:			 cd->buf_size);
audio/asrc/asrc.c:		cd->ibuf[i] = cd->buf + i * sample_bytes;
audio/asrc/asrc.c:		cd->obuf[i] = cd->ibuf[i] + cd->source_frames_max * frame_bytes;
audio/asrc/asrc.c:	ret = asrc_get_required_size(dev, &cd->asrc_size,
audio/asrc/asrc.c:	cd->asrc_obj = rzalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM,
audio/asrc/asrc.c:			       cd->asrc_size);
audio/asrc/asrc.c:	if (!cd->asrc_obj) {
audio/asrc/asrc.c:			 cd->asrc_size);
audio/asrc/asrc.c:		cd->asrc_size = 0;
audio/asrc/asrc.c:	if (cd->mode == ASRC_OM_PUSH) {
audio/asrc/asrc.c:		fs_prim = cd->source_rate;
audio/asrc/asrc.c:		fs_sec = cd->sink_rate;
audio/asrc/asrc.c:		fs_prim = cd->sink_rate;
audio/asrc/asrc.c:		fs_sec = cd->source_rate;
audio/asrc/asrc.c:	ret = asrc_initialise(dev, cd->asrc_obj, audio_stream_get_channels(&sourceb->stream),
audio/asrc/asrc.c:			      ASRC_BM_LINEAR, cd->frames, sample_bits,
audio/asrc/asrc.c:			      ASRC_CM_FEEDBACK, cd->mode);
audio/asrc/asrc.c:	ret = asrc_initialize_buffers(cd->asrc_obj);
audio/asrc/asrc.c:	if (!cd->skew)
audio/asrc/asrc.c:		cd->skew = Q_CONVERT_FLOAT(1.0, 30);
audio/asrc/asrc.c:	cd->skew_min = cd->skew;
audio/asrc/asrc.c:	cd->skew_max = cd->skew;
audio/asrc/asrc.c:	comp_info(dev, "asrc_prepare(), skew = %d", cd->skew);
audio/asrc/asrc.c:	ret = asrc_update_drift(dev, cd->asrc_obj, cd->skew);
audio/asrc/asrc.c:	asrc_release_buffers(cd->asrc_obj);
audio/asrc/asrc.c:	rfree(cd->asrc_obj);
audio/asrc/asrc.c:	cd->asrc_obj = NULL;
audio/asrc/asrc.c:	rfree(cd->buf);
audio/asrc/asrc.c:	cd->buf = NULL;
audio/asrc/asrc.c:	if (!cd->track_drift)
audio/asrc/asrc.c:	if (!cd->ts_count) {
audio/asrc/asrc.c:		cd->ts_count++;
audio/asrc/asrc.c:	delta_ts = ts - cd->ts_prev;
audio/asrc/asrc.c:	delta_sample = sample - cd->sample_prev;
audio/asrc/asrc.c:	cd->ts_prev = ts;
audio/asrc/asrc.c:	cd->sample_prev = sample;
audio/asrc/asrc.c:	if (cd->ts_count < TS_STABLE_DIFF_COUNT) {
audio/asrc/asrc.c:		cd->ts_count++;
audio/asrc/asrc.c:	f_ck_fs = ((int64_t)cd->asrc_obj->fs_sec << 31) / tsd.walclk_rate;
audio/asrc/asrc.c:	tmp = ((int64_t)COEF_C1) * skew + ((int64_t)COEF_C2) * cd->skew;
audio/asrc/asrc.c:	cd->skew = sat_int32(Q_SHIFT_RND(tmp, 60, 30));
audio/asrc/asrc.c:	asrc_update_drift(dev, cd->asrc_obj, cd->skew);
audio/asrc/asrc.c:	cd->skew_min = MIN(cd->skew, cd->skew_min);
audio/asrc/asrc.c:	cd->skew_max = MAX(cd->skew, cd->skew_max);
audio/asrc/asrc.c:	comp_dbg(dev, "skew %d %d %d %d", delta_sample, delta_ts, skew, cd->skew);
audio/asrc/asrc.c:	if (cd->mode == ASRC_OM_PULL) {
audio/asrc/asrc.c:		 * The amount cd->sink_frames will be produced while
audio/asrc/asrc.c:		cd->source_frames = MIN(frames_src, cd->source_frames_max);
audio/asrc/asrc.c:		cd->sink_frames = cd->source_frames * cd->sink_rate /
audio/asrc/asrc.c:			cd->source_rate;
audio/asrc/asrc.c:		cd->sink_frames = MIN(cd->sink_frames, cd->sink_frames_max);
audio/asrc/asrc.c:		cd->sink_frames = MIN(cd->sink_frames, frames_snk);
audio/asrc/asrc.c:		 * ASRC will consume from source cd->source_frames while
audio/asrc/asrc.c:		cd->sink_frames = MIN(frames_snk, cd->sink_frames_max);
audio/asrc/asrc.c:		cd->source_frames = cd->sink_frames * cd->source_rate /
audio/asrc/asrc.c:			cd->sink_rate;
audio/asrc/asrc.c:		cd->source_frames = MIN(cd->source_frames,
audio/asrc/asrc.c:					cd->source_frames_max);
audio/asrc/asrc.c:		cd->source_frames = MIN(cd->source_frames, frames_src);
audio/asrc/asrc.c:	if (cd->source_frames && cd->sink_frames) {
audio/asrc/asrc.c:		cd->asrc_func(mod, source_s, sink_s, &consumed, &produced);
audio/asrc/asrc.c:	comp_info(dev, "asrc_reset(), skew_min=%d, skew_max=%d", cd->skew_min, cd->skew_max);
audio/asrc/asrc.c:	if (cd->track_drift)
audio/asrc/asrc.c:	asrc_release_buffers(cd->asrc_obj);
audio/asrc/asrc.c:	rfree(cd->asrc_obj);
audio/asrc/asrc.c:	rfree(cd->buf);
audio/asrc/asrc.c:	cd->asrc_obj = NULL;
audio/asrc/asrc.c:	cd->buf = NULL;
audio/asrc/asrc_ipc3.c:	if (cd->dai_dev)
audio/asrc/asrc_ipc3.c:		return cd->dai_dev->drv->ops.dai_ts_config(cd->dai_dev);
audio/asrc/asrc_ipc3.c:	if (cd->dai_dev)
audio/asrc/asrc_ipc3.c:		return cd->dai_dev->drv->ops.dai_ts_start(cd->dai_dev);
audio/asrc/asrc_ipc3.c:	if (cd->dai_dev)
audio/asrc/asrc_ipc3.c:		return cd->dai_dev->drv->ops.dai_ts_stop(cd->dai_dev);
audio/asrc/asrc_ipc3.c:	if (!cd->dai_dev)
audio/asrc/asrc_ipc3.c:	return cd->dai_dev->drv->ops.dai_ts_get(cd->dai_dev, tsd);
audio/asrc/asrc_ipc4.c:	if (!cd->dai_dev)
audio/asrc/asrc_ipc4.c:	struct processing_module *mod = comp_get_drvdata(cd->dai_dev);
audio/asrc/asrc_ipc4.c:	return ops->endpoint_ops->dai_ts_config(cd->dai_dev);
audio/asrc/asrc_ipc4.c:	if (!cd->dai_dev)
audio/asrc/asrc_ipc4.c:	struct processing_module *mod = comp_get_drvdata(cd->dai_dev);
audio/asrc/asrc_ipc4.c:	return ops->endpoint_ops->dai_ts_start(cd->dai_dev);
audio/asrc/asrc_ipc4.c:	if (!cd->dai_dev)
audio/asrc/asrc_ipc4.c:	struct processing_module *mod = comp_get_drvdata(cd->dai_dev);
audio/asrc/asrc_ipc4.c:	return ops->endpoint_ops->dai_ts_stop(cd->dai_dev);
audio/asrc/asrc_ipc4.c:	if (!cd->dai_dev)
audio/asrc/asrc_ipc4.c:	struct processing_module *mod = comp_get_drvdata(cd->dai_dev);
audio/asrc/asrc_ipc4.c:	return ops->endpoint_ops->dai_ts_get(cd->dai_dev, tsd);
audio/asrc/asrc_ipc4.c:	ipc4_update_buffer_format(buf_c, &cd->ipc_config.base.audio_fmt);
audio/asrc/asrc_ipc4.c:	ipc4_base_module_cfg_to_stream_params(&cd->ipc_config.base, params);
audio/chain_dma.c:	err = dma_start(cd->chan_host->dma->z_dev, cd->chan_host->index);
audio/chain_dma.c:		  cd->chan_host->index);
audio/chain_dma.c:	err = dma_start(cd->chan_link->dma->z_dev, cd->chan_link->index);
audio/chain_dma.c:		  cd->chan_link->index);
audio/chain_dma.c:	err = dma_stop(cd->chan_link->dma->z_dev, cd->chan_link->index);
audio/chain_dma.c:		  cd->chan_link->index);
audio/chain_dma.c:	err = dma_stop(cd->chan_host->dma->z_dev, cd->chan_host->index);
audio/chain_dma.c:		  cd->chan_host->index);
audio/chain_dma.c:	if (cd->link_connector_node_id.f.dma_type == ipc4_hda_link_output_class &&
audio/chain_dma.c:	    !cd->xrun_notification_sent) {
audio/chain_dma.c:		xrun_notif_msg_init(cd->msg_xrun, cd->link_connector_node_id.dw,
audio/chain_dma.c:		ipc_msg_send(cd->msg_xrun, NULL, true);
audio/chain_dma.c:		cd->xrun_notification_sent = true;
audio/chain_dma.c:	} else if (cd->link_connector_node_id.f.dma_type == ipc4_hda_link_input_class &&
audio/chain_dma.c:		   !cd->xrun_notification_sent) {
audio/chain_dma.c:		xrun_notif_msg_init(cd->msg_xrun, cd->link_connector_node_id.dw,
audio/chain_dma.c:		ipc_msg_send(cd->msg_xrun, NULL, true);
audio/chain_dma.c:		cd->xrun_notification_sent = true;
audio/chain_dma.c:		cd->xrun_notification_sent = false;
audio/chain_dma.c:	ret = dma_get_status(cd->chan_link->dma->z_dev, cd->chan_link->index, &stat);
audio/chain_dma.c:	ret = dma_get_status(cd->chan_host->dma->z_dev, cd->chan_host->index, &stat);
audio/chain_dma.c:	link_type = cd->link_connector_node_id.f.dma_type;
audio/chain_dma.c:		ret = dma_reload(cd->chan_host->dma->z_dev, cd->chan_host->index, 0, 0, increment);
audio/chain_dma.c:		ret = dma_reload(cd->chan_link->dma->z_dev, cd->chan_link->index, 0, 0, increment);
audio/chain_dma.c:		const size_t buff_size = audio_stream_get_size(&cd->dma_buffer->stream);
audio/chain_dma.c:		if (!cd->first_data_received && host_avail_bytes > half_buff_size) {
audio/chain_dma.c:			ret = dma_reload(cd->chan_link->dma->z_dev,
audio/chain_dma.c:					 cd->chan_link->index, 0, 0,
audio/chain_dma.c:			cd->first_data_received = true;
audio/chain_dma.c:		} else if (cd->first_data_received) {
audio/chain_dma.c:			ret = dma_reload(cd->chan_host->dma->z_dev, cd->chan_host->index,
audio/chain_dma.c:				ret = dma_reload(cd->chan_link->dma->z_dev, cd->chan_link->index,
audio/chain_dma.c:	comp_info(dev, "chain_task_start(), host_dma_id = 0x%08x", cd->host_connector_node_id.dw);
audio/chain_dma.c:	switch (cd->chain_task.state) {
audio/chain_dma.c:	if (cd->stream_direction == SOF_IPC_STREAM_PLAYBACK) {
audio/chain_dma.c:	ret = schedule_task_init_ll(&cd->chain_task, SOF_UUID(chain_dma_uuid),
audio/chain_dma.c:	ret = schedule_task(&cd->chain_task, 0, 0);
audio/chain_dma.c:		schedule_task_free(&cd->chain_task);
audio/chain_dma.c:	if (cd->chain_task.state == SOF_TASK_STATE_FREE)
audio/chain_dma.c:	cd->first_data_received = false;
audio/chain_dma.c:	if (cd->stream_direction == SOF_IPC_STREAM_PLAYBACK) {
audio/chain_dma.c:	schedule_task_free(&cd->chain_task);
audio/chain_dma.c:	dma_release_channel(cd->chan_host->dma->z_dev, cd->chan_host->index);
audio/chain_dma.c:	dma_put(cd->dma_host);
audio/chain_dma.c:	dma_release_channel(cd->chan_link->dma->z_dev, cd->chan_link->index);
audio/chain_dma.c:	dma_put(cd->dma_link);
audio/chain_dma.c:	if (cd->dma_buffer) {
audio/chain_dma.c:		buffer_free(cd->dma_buffer);
audio/chain_dma.c:		cd->dma_buffer = NULL;
audio/chain_dma.c:	struct dma_block_config *dma_block_cfg_host = &cd->dma_block_cfg_host;
audio/chain_dma.c:	struct dma_block_config *dma_block_cfg_link = &cd->dma_block_cfg_link;
audio/chain_dma.c:	struct dma_config *dma_cfg_host = &cd->z_config_host;
audio/chain_dma.c:	struct dma_config *dma_cfg_link = &cd->z_config_link;
audio/chain_dma.c:	dma_cfg_host->source_data_size = cd->cs;
audio/chain_dma.c:	dma_cfg_host->dest_data_size = cd->cs;
audio/chain_dma.c:	dma_cfg_link->source_data_size = cd->cs;
audio/chain_dma.c:	dma_cfg_link->dest_data_size = cd->cs;
audio/chain_dma.c:	switch (cd->stream_direction) {
audio/chain_dma.c:	channel = cd->host_connector_node_id.f.v_index;
audio/chain_dma.c:	channel = dma_request_channel(cd->dma_host->z_dev, &channel);
audio/chain_dma.c:	cd->chan_host = &cd->dma_host->chan[channel];
audio/chain_dma.c:	err = dma_config(cd->dma_host->z_dev, cd->chan_host->index, dma_cfg_host);
audio/chain_dma.c:	channel = cd->link_connector_node_id.f.v_index;
audio/chain_dma.c:	channel = dma_request_channel(cd->dma_link->z_dev, &channel);
audio/chain_dma.c:	cd->chan_link = &cd->dma_link->chan[channel];
audio/chain_dma.c:	err = dma_config(cd->dma_link->z_dev, cd->chan_link->index, dma_cfg_link);
audio/chain_dma.c:	dma_release_channel(cd->dma_link->z_dev, cd->chan_link->index);
audio/chain_dma.c:	cd->chan_link = NULL;
audio/chain_dma.c:	dma_release_channel(cd->dma_host->z_dev, cd->chan_host->index);
audio/chain_dma.c:	cd->chan_host = NULL;
audio/chain_dma.c:	ret = get_connector_node_id(host_dma_id, true, &cd->host_connector_node_id);
audio/chain_dma.c:	ret = get_connector_node_id(link_dma_id, false, &cd->link_connector_node_id);
audio/chain_dma.c:	if (cd->host_connector_node_id.f.dma_type == ipc4_hda_host_output_class) {
audio/chain_dma.c:		if (cd->link_connector_node_id.f.dma_type != ipc4_hda_link_output_class)
audio/chain_dma.c:		cd->stream_direction = SOF_IPC_STREAM_PLAYBACK;
audio/chain_dma.c:	if (cd->host_connector_node_id.f.dma_type == ipc4_hda_host_input_class) {
audio/chain_dma.c:		if (cd->link_connector_node_id.f.dma_type != ipc4_hda_link_input_class)
audio/chain_dma.c:		cd->stream_direction = SOF_IPC_STREAM_CAPTURE;
audio/chain_dma.c:	dir = (cd->stream_direction == SOF_IPC_STREAM_PLAYBACK) ?
audio/chain_dma.c:	cd->dma_host = dma_get(dir, 0, DMA_DEV_HOST, DMA_ACCESS_SHARED);
audio/chain_dma.c:	if (!cd->dma_host) {
audio/chain_dma.c:	dir = (cd->stream_direction == SOF_IPC_STREAM_PLAYBACK) ?
audio/chain_dma.c:	cd->dma_link = dma_get(dir, DMA_CAP_HDA, DMA_DEV_HDA, DMA_ACCESS_SHARED);
audio/chain_dma.c:	if (!cd->dma_link) {
audio/chain_dma.c:		dma_put(cd->dma_host);
audio/chain_dma.c:	ret = dma_get_attribute(cd->dma_host->z_dev, DMA_ATTR_BUFFER_ADDRESS_ALIGNMENT,
audio/chain_dma.c:	switch (cd->link_connector_node_id.f.dma_type) {
audio/chain_dma.c:	cd->dma_buffer = buffer_alloc(fifo_size, SOF_MEM_CAPS_DMA, 0, addr_align, false);
audio/chain_dma.c:	if (!cd->dma_buffer) {
audio/chain_dma.c:	buffer_zero(cd->dma_buffer);
audio/chain_dma.c:	buff_addr = audio_stream_get_addr(&cd->dma_buffer->stream);
audio/chain_dma.c:	buff_size = audio_stream_get_size(&cd->dma_buffer->stream);
audio/chain_dma.c:		buffer_free(cd->dma_buffer);
audio/chain_dma.c:		cd->dma_buffer = NULL;
audio/chain_dma.c:	cd->chain_task.state = SOF_TASK_STATE_INIT;
audio/chain_dma.c:	dma_put(cd->dma_host);
audio/chain_dma.c:	dma_put(cd->dma_link);
audio/chain_dma.c:	cd->first_data_received = false;
audio/chain_dma.c:	cd->cs = scs ? 2 : 4;
audio/chain_dma.c:	cd->chain_task.state = SOF_TASK_STATE_INIT;
audio/chain_dma.c:	cd->msg_xrun = ipc_msg_init(header.dat,
audio/chain_dma.c:	if (!cd->msg_xrun)
audio/chain_dma.c:	cd->xrun_notification_sent = false;
audio/chain_dma.c:	ipc_msg_free(cd->msg_xrun);
audio/copier/copier.c:	if (memcpy_s(&cd->config, sizeof(cd->config), copier, sizeof(*copier)) < 0) {
audio/copier/copier.c:		cd->gtw_cfg = gtw_cfg;
audio/copier/copier.c:		cd->out_fmt[i] = cd->config.out_fmt;
audio/copier/copier.c:		cd->direction = get_gateway_direction(node_id.f.dma_type);
audio/copier/copier.c:	dev->direction = cd->direction;
audio/copier/copier.c:		if (!cd->ipc_gtw)
audio/copier/copier.c:		rfree(cd->gtw_cfg);
audio/copier/copier.c:		if (!cd->ipc_gtw) {
audio/copier/copier.c:			ret = host_common_prepare(cd->hd);
audio/copier/copier.c:	if (!cd->endpoint_num) {
audio/copier/copier.c:		cd->converter[0] = get_converter_func(&cd->config.base.audio_fmt,
audio/copier/copier.c:							      &cd->config.out_fmt, ipc4_gtw_none,
audio/copier/copier.c:		if (!cd->converter[0]) {
audio/copier/copier.c:				 cd->config.base.audio_fmt.depth,  cd->config.out_fmt.depth);
audio/copier/copier.c:	cd->input_total_data_processed = 0;
audio/copier/copier.c:	cd->output_total_data_processed = 0;
audio/copier/copier.c:		if (!cd->ipc_gtw)
audio/copier/copier.c:			host_common_reset(cd->hd, dev->state);
audio/copier/copier.c:	if (cd->pipeline_reg_offset) {
audio/copier/copier.c:		mailbox_sw_regs_write(cd->pipeline_reg_offset, &pipe_reg, sizeof(pipe_reg));
audio/copier/copier.c:		if (!cd->ipc_gtw) {
audio/copier/copier.c:			ret = host_common_trigger(cd->hd, dev, cmd);
audio/copier/copier.c:	/* For capture cd->pipeline_reg_offset == 0 */
audio/copier/copier.c:	if (!cd->endpoint_num || !cd->pipeline_reg_offset)
audio/copier/copier.c:		mailbox_sw_regs_write(cd->pipeline_reg_offset, &pipe_reg, sizeof(pipe_reg));
audio/copier/copier.c:		mailbox_sw_regs_write(cd->pipeline_reg_offset, &pipe_reg, sizeof(pipe_reg));
audio/copier/copier.c:		mailbox_sw_regs_write(cd->pipeline_reg_offset + sizeof(uint64_t),
audio/copier/copier.c:		pipe_reg.stream_start_offset = mailbox_sw_reg_read64(cd->pipeline_reg_offset);
audio/copier/copier.c:		pipe_reg.stream_end_offset = mailbox_sw_reg_read64(cd->pipeline_reg_offset +
audio/copier/copier.c:		mailbox_sw_regs_write(cd->pipeline_reg_offset, &pipe_reg.stream_start_offset,
audio/copier/copier.c:	cd->converter[i](&src->stream, 0, &sink->stream, 0,
audio/copier/copier.c:			cd->output_total_data_processed += processed_data->sink_bytes;
audio/copier/copier.c:		if (!cd->endpoint_num || cd->bsource_buffer)
audio/copier/copier.c:			cd->input_total_data_processed += processed_data->source_bytes;
audio/copier/copier.c:			ipc4_update_buffer_format(sink_c, &cd->out_fmt[sink_queue_id]);
audio/copier/copier.c:			cd->converter[sink_queue_id](input_buffers[0].data, 0,
audio/copier/copier.c:			cd->output_total_data_processed += processed_data.sink_bytes;
audio/copier/copier.c:	if (!cd->bsource_buffer) {
audio/copier/copier.c:		ret = dai_zephyr_multi_endpoint_copy(cd->dd, dev, cd->multi_endpoint_buffer,
audio/copier/copier.c:						     cd->endpoint_num);
audio/copier/copier.c:		ret = copier_copy_to_sinks(cd, dev, cd->multi_endpoint_buffer, &processed_data);
audio/copier/copier.c:	ret = do_conversion_copy(dev, cd, src, cd->multi_endpoint_buffer, &processed_data);
audio/copier/copier.c:	ret = dai_zephyr_multi_endpoint_copy(cd->dd, dev, cd->multi_endpoint_buffer,
audio/copier/copier.c:					     cd->endpoint_num);
audio/copier/copier.c:		cd->input_total_data_processed += processed_data.source_bytes;
audio/copier/copier.c:		if (!cd->ipc_gtw)
audio/copier/copier.c:			return host_common_copy(cd->hd, dev, copier_host_dma_cb);
audio/copier/copier.c:		if (cd->endpoint_num == 1)
audio/copier/copier.c:			return dai_common_copy(cd->dd[0], dev, cd->converter);
audio/copier/copier.c:	for (i = 0; i < cd->endpoint_num; i++) {
audio/copier/copier.c:			if (!cd->ipc_gtw)
audio/copier/copier.c:				ret = copier_ipcgtw_params(cd->ipcgtw_data, dev, params);
audio/copier/copier.c:	if (memcmp(&cd->config.base.audio_fmt, &sink_fmt->source_fmt,
audio/copier/copier.c:	if (cd->endpoint_num && cd->bsource_buffer &&
audio/copier/copier.c:	cd->out_fmt[sink_fmt->sink_id] = sink_fmt->sink_fmt;
audio/copier/copier.c:	cd->converter[sink_fmt->sink_id] = get_converter_func(&sink_fmt->source_fmt,
audio/copier/copier.c:	audio_stream_fmt_conversion(cd->config.out_fmt.depth,
audio/copier/copier.c:				    cd->config.out_fmt.valid_bit_depth,
audio/copier/copier.c:				    cd->config.out_fmt.s_type);
audio/copier/copier.c:	cd->attenuation = attenuation;
audio/copier/copier.c:	if (cd->ipc_gtw)
audio/copier/copier.c:		if (!cd->endpoint_num ||
audio/copier/copier.c:		if (!cd->endpoint_num ||
audio/copier/copier.c:	if (cd->endpoint_num) {
audio/copier/copier.c:		if (stream_no < cd->endpoint_num) {
audio/copier/copier.c:				if (!cd->ipc_gtw && source == input)
audio/copier/copier.c:					ret = cd->hd->total_data_processed;
audio/copier/copier.c:					ret = cd->dd[0]->total_data_processed;
audio/copier/copier.c:				ret = comp_get_total_data_processed(cd->endpoint[stream_no],
audio/copier/copier.c:			ret = input ? cd->input_total_data_processed :
audio/copier/copier.c:				      cd->output_total_data_processed;
audio/copier/copier.c:	if (!cd->endpoint_num)
audio/copier/copier.c:		if (!cd->ipc_gtw) {
audio/copier/copier.c:			posn->host_posn = cd->hd->local_pos;
audio/copier/copier.c:		ret = dai_common_position(cd->dd[0], dev, posn);
audio/copier/copier.c:	struct dai_data *dd = cd->dd[0];
audio/copier/copier.c:	struct dai_data *dd = cd->dd[0];
audio/copier/copier.c:	struct dai_data *dd = cd->dd[0];
audio/copier/copier.c:	struct dai_data *dd = cd->dd[0];
audio/copier/copier.c:	struct dai_data *dd = cd->dd[0];
audio/copier/copier.c:		struct dai_data *dd = cd->dd[0];
audio/copier/copier_dai.c:	cd->channels[index] = channels;
audio/copier/copier_dai.c:	cd->chan_map[index] = bitmask_to_nibble_channel_map(chan_bitmask);
audio/copier/copier_dai.c:	if (!cd->config.gtw_cfg.config_length) {
audio/copier/copier_dai.c:		dma_config_length = (cd->config.gtw_cfg.config_length << 2) - alh_cfg_size;
audio/copier/copier_dai.c:	if (cd->direction == SOF_IPC_STREAM_PLAYBACK) {
audio/copier/copier_dai.c:		cd->bsource_buffer = true;
audio/copier/copier_dai.c:	cd->dd[index] = dd;
audio/copier/copier_dai.c:	ret = comp_dai_config(cd->dd[index], dev, dai, copier);
audio/copier/copier_dai.c:	cd->endpoint_num++;
audio/copier/copier_dai.c:		ret = ipc4_find_dma_config(&dai, (uint8_t *)cd->gtw_cfg,
audio/copier/copier_dai.c:		ret = copier_alh_assign_dai_index(dev, cd->gtw_cfg, node_id,
audio/copier/copier_dai.c:		ret = ipc4_find_dma_config(&dai, (uint8_t *)cd->gtw_cfg,
audio/copier/copier_dai.c:	cd->converter[IPC4_COPIER_GATEWAY_PIN] =
audio/copier/copier_dai.c:	if (!cd->converter[IPC4_COPIER_GATEWAY_PIN]) {
audio/copier/copier_dai.c:	if (cd->direction == SOF_IPC_STREAM_PLAYBACK) {
audio/copier/copier_dai.c:	for (int i = 0; i < cd->endpoint_num; i++) {
audio/copier/copier_dai.c:		dai_common_free(cd->dd[i]);
audio/copier/copier_dai.c:		rfree(cd->dd[i]);
audio/copier/copier_dai.c:	if (cd->multi_endpoint_buffer)
audio/copier/copier_dai.c:		buffer_free(cd->multi_endpoint_buffer);
audio/copier/copier_dai.c:	for (int i = 0; i < cd->endpoint_num; i++) {
audio/copier/copier_dai.c:		ret = dai_common_config_prepare(cd->dd[i], dev);
audio/copier/copier_dai.c:		ret = dai_common_prepare(cd->dd[i], dev);
audio/copier/copier_dai.c:	const struct ipc4_audio_format *in_fmt = &cd->config.base.audio_fmt;
audio/copier/copier_dai.c:	const struct ipc4_audio_format *out_fmt = &cd->config.out_fmt;
audio/copier/copier_dai.c:	if (cd->endpoint_num == 1) {
audio/copier/copier_dai.c:		ret = dai_common_params(cd->dd[0], dev, params);
audio/copier/copier_dai.c:			cd->dd[0]->process =
audio/copier/copier_dai.c:				cd->converter[IPC4_COPIER_GATEWAY_PIN];
audio/copier/copier_dai.c:	demuxed_params.channels = cd->channels[dai_index];
audio/copier/copier_dai.c:	ret = dai_common_params(cd->dd[dai_index], dev, &demuxed_params);
audio/copier/copier_dai.c:		cd->dd[dai_index]->dma_buffer->chmap[j] = (cd->chan_map[dai_index] >> j * 4) & 0xf;
audio/copier/copier_dai.c:	container_size = audio_stream_sample_bytes(&cd->multi_endpoint_buffer->stream);
audio/copier/copier_dai.c:		cd->dd[dai_index]->process = copy_single_channel_c16;
audio/copier/copier_dai.c:		cd->dd[dai_index]->process = copy_single_channel_c32;
audio/copier/copier_dai.c:	for (int i = 0; i < cd->endpoint_num; i++)
audio/copier/copier_dai.c:		dai_common_reset(cd->dd[i], dev);
audio/copier/copier_dai.c:	for (int i = 0; i < cd->endpoint_num; i++) {
audio/copier/copier_dai.c:		ret = dai_common_trigger(cd->dd[i], dev, cmd);
audio/copier/copier_generic.c:				*dst >>= cd->attenuation;
audio/copier/copier_generic.c:	params->direction = cd->direction;
audio/copier/copier_generic.c:	params->channels = cd->config.base.audio_fmt.channels_count;
audio/copier/copier_generic.c:	params->rate = cd->config.base.audio_fmt.sampling_frequency;
audio/copier/copier_generic.c:	params->sample_container_bytes = cd->config.base.audio_fmt.depth / 8;
audio/copier/copier_generic.c:	params->sample_valid_bytes = cd->config.base.audio_fmt.valid_bit_depth / 8;
audio/copier/copier_generic.c:	params->stream_tag = cd->config.gtw_cfg.node_id.f.v_index + 1;
audio/copier/copier_generic.c:	params->buffer_fmt = cd->config.base.audio_fmt.interleaving_style;
audio/copier/copier_generic.c:	params->buffer.size = cd->config.base.ibs;
audio/copier/copier_generic.c:		ipc4_update_buffer_format(sink, &cd->out_fmt[j]);
audio/copier/copier_generic.c:		in_fmt = &cd->config.base.audio_fmt;
audio/copier/copier_generic.c:		if (cd->ipc_gtw || params->direction == SOF_IPC_STREAM_PLAYBACK)
audio/copier/copier_generic.c:		    (cd->endpoint_num > 1 || params->direction == SOF_IPC_STREAM_CAPTURE))
audio/copier/copier_generic.c:		params->buffer.size = cd->config.base.obs;
audio/copier/copier_generic.c:		params->sample_container_bytes = cd->out_fmt->depth / 8;
audio/copier/copier_generic.c:		params->sample_valid_bytes = cd->out_fmt->valid_bit_depth / 8;
audio/copier/copier_generic.c:	if (cd->direction == SOF_IPC_STREAM_PLAYBACK) {
audio/copier/copier_generic.c:		cd->multi_endpoint_buffer = buffer;
audio/copier/copier_generic.c:		cd->endpoint_buffer[cd->endpoint_num] = buffer;
audio/copier/copier_hifi.c:				sample = AE_SRAA32(sample, cd->attenuation);
audio/copier/copier_hifi.c:				sample = AE_SRAA32(sample, cd->attenuation);
audio/copier/copier_host.c:	gateway_id = cd->config.gtw_cfg.node_id.f.v_index;
audio/copier/copier_host.c:	cd->pipeline_reg_offset = offsetof(struct ipc4_fw_registers, pipeline_regs);
audio/copier/copier_host.c:	cd->pipeline_reg_offset += gateway_id * sizeof(struct ipc4_pipeline_registers);
audio/copier/copier_host.c:	mailbox_sw_regs_write(cd->pipeline_reg_offset, &pipe_reg, sizeof(pipe_reg));
audio/copier/copier_host.c:	int dir = cd->direction;
audio/copier/copier_host.c:	cd->converter[IPC4_COPIER_GATEWAY_PIN] =
audio/copier/copier_host.c:	if (!cd->converter[IPC4_COPIER_GATEWAY_PIN]) {
audio/copier/copier_host.c:	cd->endpoint_num++;
audio/copier/copier_host.c:	cd->hd = hd;
audio/copier/copier_host.c:	if (cd->direction == SOF_IPC_STREAM_PLAYBACK) {
audio/copier/copier_host.c:	if (cd->hd->is_grouped)
audio/copier/copier_host.c:		delete_from_fpi_sync_group(cd->hd);
audio/copier/copier_host.c:	host_common_free(cd->hd);
audio/copier/copier_host.c:	rfree(cd->hd);
audio/copier/copier_host.c:	host_common_update(cd->hd, dev, bytes);
audio/copier/copier_host.c:	if (cd->hd->copy_type == COMP_COPY_ONE_SHOT)
audio/copier/copier_host.c:		host_common_one_shot(cd->hd, bytes);
audio/copier/copier_host.c:	if (cd->attenuation && dev->direction == SOF_IPC_STREAM_PLAYBACK) {
audio/copier/copier_host.c:		frames = bytes / audio_stream_frame_bytes(&cd->hd->dma_buffer->stream);
audio/copier/copier_host.c:		ret = apply_attenuation(dev, cd, cd->hd->local_buffer, frames);
audio/copier/copier_host.c:		buffer_stream_writeback(cd->hd->local_buffer, bytes);
audio/copier/copier_host.c:	ret = host_common_params(cd->hd, dev, params,
audio/copier/copier_host.c:	cd->hd->process = cd->converter[IPC4_COPIER_GATEWAY_PIN];
audio/copier/copier_ipcgtw.c:	cd->ipc_gtw = true;
audio/copier/copier_ipcgtw.c:	cd->converter[IPC4_COPIER_GATEWAY_PIN] =
audio/copier/copier_ipcgtw.c:				   ipc4_gtw_host, IPC4_DIRECTION(cd->direction));
audio/copier/copier_ipcgtw.c:	if (!cd->converter[IPC4_COPIER_GATEWAY_PIN]) {
audio/copier/copier_ipcgtw.c:			 cd->direction);
audio/copier/copier_ipcgtw.c:	if (cd->direction == SOF_IPC_STREAM_PLAYBACK) {
audio/copier/copier_ipcgtw.c:				    cd->endpoint_buffer[cd->endpoint_num],
audio/copier/copier_ipcgtw.c:		cd->bsource_buffer = false;
audio/copier/copier_ipcgtw.c:				    cd->endpoint_buffer[cd->endpoint_num],
audio/copier/copier_ipcgtw.c:		cd->bsource_buffer = true;
audio/copier/copier_ipcgtw.c:	cd->ipcgtw_data = ipcgtw_data;
audio/copier/copier_ipcgtw.c:	cd->endpoint_num++;
audio/copier/copier_ipcgtw.c:	buffer_free(cd->endpoint_buffer[cd->endpoint_num]);
audio/copier/copier_ipcgtw.c:	list_item_del(&cd->ipcgtw_data->item);
audio/copier/copier_ipcgtw.c:	rfree(cd->ipcgtw_data);
audio/copier/copier_ipcgtw.c:	buffer_free(cd->endpoint_buffer[0]);
audio/crossover/crossover.c:		crossover_reset_state_ch(&cd->state[i]);
audio/crossover/crossover.c:	struct sof_crossover_config *config = cd->config;
audio/crossover/crossover.c:	struct sof_crossover_config *config = cd->config;
audio/crossover/crossover.c:		err = crossover_init_coef_ch(crossover, &cd->state[ch],
audio/crossover/crossover.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/crossover/crossover.c:	if (!cd->model_handler) {
audio/crossover/crossover.c:	ret = comp_init_data_blob(cd->model_handler, bs, ipc_crossover->data);
audio/crossover/crossover.c:	comp_data_blob_handler_free(cd->model_handler);
audio/crossover/crossover.c:	comp_data_blob_handler_free(cd->model_handler);
audio/crossover/crossover.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment,
audio/crossover/crossover.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/crossover/crossover.c:	if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/crossover/crossover.c:		cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/crossover/crossover.c:	if (cd->config && num_assigned_sinks != cd->config->num_sinks)
audio/crossover/crossover.c:			 num_assigned_sinks, cd->config->num_sinks);
audio/crossover/crossover.c:	if (cd->config)
audio/crossover/crossover.c:		num_sinks = cd->config->num_sinks;
audio/crossover/crossover.c:	cd->crossover_process(cd, input_buffers, assigned_obufs, num_sinks, frames);
audio/crossover/crossover.c:	cd->source_format = audio_stream_get_frm_fmt(&source->stream);
audio/crossover/crossover.c:		if (cd->source_format != audio_stream_get_frm_fmt(&sink->stream)) {
audio/crossover/crossover.c:				 cd->source_format, audio_stream_get_frm_fmt(&sink->stream));
audio/crossover/crossover.c:		  cd->source_format, cd->source_format, channels);
audio/crossover/crossover.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/crossover/crossover.c:	if (cd->config && crossover_validate_config(mod, cd->config) < 0) {
audio/crossover/crossover.c:		crossover_free_config(&cd->config);
audio/crossover/crossover.c:	if (cd->config) {
audio/crossover/crossover.c:		cd->crossover_process = crossover_find_proc_func(cd->source_format);
audio/crossover/crossover.c:		if (!cd->crossover_process) {
audio/crossover/crossover.c:				 cd->source_format);
audio/crossover/crossover.c:		cd->crossover_split = crossover_find_split_func(cd->config->num_sinks);
audio/crossover/crossover.c:		if (!cd->crossover_split) {
audio/crossover/crossover.c:				 cd->config->num_sinks);
audio/crossover/crossover.c:		cd->crossover_process = crossover_find_proc_func_pass(cd->source_format);
audio/crossover/crossover.c:		if (!cd->crossover_process) {
audio/crossover/crossover.c:				 cd->source_format);
audio/crossover/crossover.c:	cd->crossover_process = NULL;
audio/crossover/crossover.c:	cd->crossover_split = NULL;
audio/crossover/crossover_generic.c:		state = &cd->state[ch];
audio/crossover/crossover_generic.c:			cd->crossover_split(*x << 16, out, state);
audio/crossover/crossover_generic.c:		state = &cd->state[ch];
audio/crossover/crossover_generic.c:			cd->crossover_split(*x << 8, out, state);
audio/crossover/crossover_generic.c:		state = &cd->state[ch];
audio/crossover/crossover_generic.c:			cd->crossover_split(*x, out, state);
audio/crossover/crossover_ipc4.c:	return cd->output_pin_index[index];
audio/crossover/crossover_ipc4.c:	cd->num_output_pins = num_output_pins;
audio/crossover/crossover_ipc4.c:		cd->output_pin_index[i] = output_pin[i].pin_index;
audio/crossover/crossover_ipc4.c:	for (j = 0; j < cd->num_output_pins; j++) {
audio/crossover/crossover_ipc4.c:		pin_index = cd->output_pin_index[j];
audio/dcblock/dcblock.c:		cd->R_coeffs[i] = ONE_Q2_30;
audio/dcblock/dcblock.c:	memcpy_s(cd->R_coeffs, sizeof(cd->R_coeffs), cd->config, sizeof(cd->R_coeffs));
audio/dcblock/dcblock.c:	memset(cd->state, 0, sizeof(cd->state));
audio/dcblock/dcblock.c:	cd->dcblock_func = NULL;
audio/dcblock/dcblock.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/dcblock/dcblock.c:	if (!cd->model_handler) {
audio/dcblock/dcblock.c:	ret = comp_init_data_blob(cd->model_handler, bs, ipc_dcblock->data);
audio/dcblock/dcblock.c:	comp_data_blob_handler_free(cd->model_handler);
audio/dcblock/dcblock.c:	comp_data_blob_handler_free(cd->model_handler);
audio/dcblock/dcblock.c:	cd->dcblock_func(cd, source, sink, frames);
audio/dcblock/dcblock.c:	cd->source_format = audio_stream_get_frm_fmt(&sourceb->stream);
audio/dcblock/dcblock.c:	cd->sink_format = audio_stream_get_frm_fmt(&sinkb->stream);
audio/dcblock/dcblock.c:	cd->dcblock_func = dcblock_find_func(cd->source_format);
audio/dcblock/dcblock.c:	if (!cd->dcblock_func) {
audio/dcblock/dcblock.c:		  cd->source_format, cd->sink_format);
audio/dcblock/dcblock.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/dcblock/dcblock.c:	if (cd->config)
audio/dcblock/dcblock.c:	cd->dcblock_func = NULL;
audio/dcblock/dcblock_generic.c:			state = &cd->state[ch];
audio/dcblock/dcblock_generic.c:			R = cd->R_coeffs[ch];
audio/dcblock/dcblock_generic.c:			state = &cd->state[ch];
audio/dcblock/dcblock_generic.c:			R = cd->R_coeffs[ch];
audio/dcblock/dcblock_generic.c:			state = &cd->state[ch];
audio/dcblock/dcblock_generic.c:			R = cd->R_coeffs[ch];
audio/dcblock/dcblock_hifi3.c:			state_x = cd->state[ch].x_prev;
audio/dcblock/dcblock_hifi3.c:			state_y = cd->state[ch].y_prev;
audio/dcblock/dcblock_hifi3.c:			R = cd->R_coeffs[ch];
audio/dcblock/dcblock_hifi3.c:			cd->state[ch].x_prev = state_x;
audio/dcblock/dcblock_hifi3.c:			cd->state[ch].y_prev = state_y;
audio/dcblock/dcblock_hifi3.c:			state_x = cd->state[ch].x_prev;
audio/dcblock/dcblock_hifi3.c:			state_y = cd->state[ch].y_prev;
audio/dcblock/dcblock_hifi3.c:			R = cd->R_coeffs[ch];
audio/dcblock/dcblock_hifi3.c:			cd->state[ch].x_prev = state_x;
audio/dcblock/dcblock_hifi3.c:			cd->state[ch].y_prev = state_y;
audio/dcblock/dcblock_hifi3.c:			state_x = cd->state[ch].x_prev;
audio/dcblock/dcblock_hifi3.c:			state_y = cd->state[ch].y_prev;
audio/dcblock/dcblock_hifi3.c:			R = cd->R_coeffs[ch];
audio/dcblock/dcblock_hifi3.c:			cd->state[ch].x_prev = state_x;
audio/dcblock/dcblock_hifi3.c:			cd->state[ch].y_prev = state_y;
audio/dcblock/dcblock_hifi4.c:		state_x = cd->state[ch].x_prev;
audio/dcblock/dcblock_hifi4.c:		state_y = cd->state[ch].y_prev;
audio/dcblock/dcblock_hifi4.c:		R = cd->R_coeffs[ch];
audio/dcblock/dcblock_hifi4.c:		cd->state[ch].x_prev = state_x;
audio/dcblock/dcblock_hifi4.c:		cd->state[ch].y_prev = state_y;
audio/dcblock/dcblock_hifi4.c:		state_x = cd->state[ch].x_prev;
audio/dcblock/dcblock_hifi4.c:		state_y = cd->state[ch].y_prev;
audio/dcblock/dcblock_hifi4.c:		R = cd->R_coeffs[ch];
audio/dcblock/dcblock_hifi4.c:		cd->state[ch].x_prev = state_x;
audio/dcblock/dcblock_hifi4.c:		cd->state[ch].y_prev = state_y;
audio/dcblock/dcblock_hifi4.c:		state_x = cd->state[ch].x_prev;
audio/dcblock/dcblock_hifi4.c:		state_y = cd->state[ch].y_prev;
audio/dcblock/dcblock_hifi4.c:		R = cd->R_coeffs[ch];
audio/dcblock/dcblock_hifi4.c:		cd->state[ch].x_prev = state_x;
audio/dcblock/dcblock_hifi4.c:		cd->state[ch].y_prev = state_y;
audio/dcblock/dcblock_ipc3.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/dcblock/dcblock_ipc3.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment,
audio/dcblock/dcblock_ipc4.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/dcblock/dcblock_ipc4.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment,
audio/drc/drc.c:	uint32_t sample_bytes = get_sample_bytes(cd->source_format);
audio/drc/drc.c:	drc_reset_state(&cd->state);
audio/drc/drc.c:	ret = drc_init_pre_delay_buffers(&cd->state, (size_t)sample_bytes, (int)channels);
audio/drc/drc.c:	return drc_set_pre_delay_time(&cd->state, cd->config->params.pre_delay_time, rate);
audio/drc/drc.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/drc/drc.c:	if (!cd->model_handler) {
audio/drc/drc.c:	ret = comp_init_data_blob(cd->model_handler, bs, cfg->data);
audio/drc/drc.c:	drc_reset_state(&cd->state);
audio/drc/drc.c:	cd->enabled = true;
audio/drc/drc.c:	cd->enable_switch = true;
audio/drc/drc.c:	comp_data_blob_handler_free(cd->model_handler);
audio/drc/drc.c:	comp_data_blob_handler_free(cd->model_handler);
audio/drc/drc.c:			cd->enable_switch = ctl->chanv[0].value;
audio/drc/drc.c:			comp_info(dev, "drc_set_config(), enable_switch = %d", cd->enable_switch);
audio/drc/drc.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment,
audio/drc/drc.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/drc/drc.c:	if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/drc/drc.c:		cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/drc/drc.c:	cd->enabled = cd->config && cd->config->params.enabled && cd->enable_switch;
audio/drc/drc.c:	cd->drc_func(mod, source, sink, frames);
audio/drc/drc.c:	cd->source_format = audio_stream_get_frm_fmt(&sourceb->stream);
audio/drc/drc.c:	comp_info(dev, "drc_prepare(), source_format=%d", cd->source_format);
audio/drc/drc.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/drc/drc.c:	if (cd->config) {
audio/drc/drc.c:		cd->drc_func = drc_find_proc_func(cd->source_format);
audio/drc/drc.c:		if (!cd->drc_func) {
audio/drc/drc.c:		cd->drc_func = drc_default_pass;
audio/drc/drc.c:	drc_reset_state(&cd->state);
audio/drc/drc_generic.c:	struct drc_state *state = &cd->state;
audio/drc/drc_generic.c:	const struct sof_drc_params *p = &cd->config->params; /* Read-only */
audio/drc/drc_generic.c:	if (!cd->enabled) {
audio/drc/drc_generic.c:	struct drc_state *state = &cd->state;
audio/drc/drc_generic.c:	const struct sof_drc_params *p = &cd->config->params; /* Read-only */
audio/drc/drc_generic.c:	if (!cd->enabled) {
audio/drc/drc_generic.c:	struct drc_state *state = &cd->state;
audio/drc/drc_generic.c:	const struct sof_drc_params *p = &cd->config->params; /* Read-only */
audio/drc/drc_generic.c:	if (!cd->enabled) {
audio/drc/drc_hifi4.c:	struct drc_state *state = &cd->state;
audio/drc/drc_hifi4.c:	const struct sof_drc_params *p = &cd->config->params; /* Read-only */
audio/drc/drc_hifi4.c:	struct drc_state *state = &cd->state;
audio/drc/drc_hifi4.c:	const struct sof_drc_params *p = &cd->config->params; /* Read-only */
audio/drc/drc_hifi4.c:	struct drc_state *state = &cd->state;
audio/drc/drc_hifi4.c:	const struct sof_drc_params *p = &cd->config->params; /* Read-only */
audio/eq_fir/eq_fir.c:	struct fir_state_32x16 *fir = cd->fir;
audio/eq_fir/eq_fir.c:	rfree(cd->fir_delay);
audio/eq_fir/eq_fir.c:	cd->fir_delay = NULL;
audio/eq_fir/eq_fir.c:	cd->fir_delay_size = 0;
audio/eq_fir/eq_fir.c:		nch = cd->nch;
audio/eq_fir/eq_fir.c:	cd->nch = nch;
audio/eq_fir/eq_fir.c:	delay_size = eq_fir_init_coef(dev, cd->config, cd->fir, nch);
audio/eq_fir/eq_fir.c:	cd->fir_delay = rballoc(0, SOF_MEM_CAPS_RAM, delay_size);
audio/eq_fir/eq_fir.c:	if (!cd->fir_delay) {
audio/eq_fir/eq_fir.c:	memset(cd->fir_delay, 0, delay_size);
audio/eq_fir/eq_fir.c:	cd->fir_delay_size = delay_size;
audio/eq_fir/eq_fir.c:	eq_fir_init_delay(cd->fir, cd->fir_delay, nch);
audio/eq_fir/eq_fir.c:	cd->eq_fir_func = NULL;
audio/eq_fir/eq_fir.c:	cd->fir_delay = NULL;
audio/eq_fir/eq_fir.c:	cd->fir_delay_size = 0;
audio/eq_fir/eq_fir.c:	cd->nch = -1;
audio/eq_fir/eq_fir.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/eq_fir/eq_fir.c:	if (!cd->model_handler) {
audio/eq_fir/eq_fir.c:	ret = comp_init_data_blob(cd->model_handler, bs, cfg->init_data);
audio/eq_fir/eq_fir.c:		fir_reset(&cd->fir[i]);
audio/eq_fir/eq_fir.c:	comp_data_blob_handler_free(cd->model_handler);
audio/eq_fir/eq_fir.c:	comp_data_blob_handler_free(cd->model_handler);
audio/eq_fir/eq_fir.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/eq_fir/eq_fir.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/eq_fir/eq_fir.c:	if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/eq_fir/eq_fir.c:		cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/eq_fir/eq_fir.c:		} else if (cd->fir_delay_size) {
audio/eq_fir/eq_fir.c:			cd->eq_fir_func = eq_fir_passthrough;
audio/eq_fir/eq_fir.c:		cd->eq_fir_func(cd->fir, &input_buffers[0], &output_buffers[0], frame_count);
audio/eq_fir/eq_fir.c:	cd->eq_fir_func = eq_fir_passthrough;
audio/eq_fir/eq_fir.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/eq_fir/eq_fir.c:	if (cd->config) {
audio/eq_fir/eq_fir.c:		else if (cd->fir_delay_size)
audio/eq_fir/eq_fir.c:	comp_data_blob_set_validator(cd->model_handler, eq_fir_validator);
audio/eq_fir/eq_fir.c:	comp_data_blob_set_validator(cd->model_handler, NULL);
audio/eq_fir/eq_fir.c:	cd->eq_fir_func = NULL;
audio/eq_fir/eq_fir.c:		fir_reset(&cd->fir[i]);
audio/eq_fir/eq_fir.h:	cd->eq_fir_func = eq_fir_2x_s16;
audio/eq_fir/eq_fir.h:	cd->eq_fir_func = eq_fir_2x_s24;
audio/eq_fir/eq_fir.h:	cd->eq_fir_func = eq_fir_2x_s32;
audio/eq_fir/eq_fir.h:	cd->eq_fir_func = eq_fir_s16;
audio/eq_fir/eq_fir.h:	cd->eq_fir_func = eq_fir_s24;
audio/eq_fir/eq_fir.h:	cd->eq_fir_func = eq_fir_s32;
audio/eq_iir/eq_iir.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/eq_iir/eq_iir.c:	if (!cd->model_handler) {
audio/eq_iir/eq_iir.c:	ret = comp_init_data_blob(cd->model_handler, bs, cfg->data);
audio/eq_iir/eq_iir.c:		comp_data_blob_handler_free(cd->model_handler);
audio/eq_iir/eq_iir.c:		iir_reset_df1(&cd->iir[i]);
audio/eq_iir/eq_iir.c:	comp_data_blob_handler_free(cd->model_handler);
audio/eq_iir/eq_iir.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment,
audio/eq_iir/eq_iir.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/eq_iir/eq_iir.c:	if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/eq_iir/eq_iir.c:		cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/eq_iir/eq_iir.c:		cd->eq_iir_func(mod, &input_buffers[0], &output_buffers[0], frame_count);
audio/eq_iir/eq_iir.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/eq_iir/eq_iir.c:	if (cd->config) {
audio/eq_iir/eq_iir.c:	if (!cd->eq_iir_func) {
audio/eq_iir/eq_iir.c:	cd->eq_iir_func = NULL;
audio/eq_iir/eq_iir.c:		iir_reset_df1(&cd->iir[i]);
audio/eq_iir/eq_iir_generic.c:			filter = &cd->iir[i];
audio/eq_iir/eq_iir_generic.c:			filter = &cd->iir[i];
audio/eq_iir/eq_iir_generic.c:			filter = &cd->iir[i];
audio/eq_iir/eq_iir_generic.c:	struct sof_eq_iir_config *config = cd->config;
audio/eq_iir/eq_iir_generic.c:	struct iir_state_df1 *iir = cd->iir;
audio/eq_iir/eq_iir_generic.c:	struct iir_state_df1 *iir = cd->iir;
audio/eq_iir/eq_iir_generic.c:	rfree(cd->iir_delay);
audio/eq_iir/eq_iir_generic.c:	cd->iir_delay = NULL;
audio/eq_iir/eq_iir_generic.c:	cd->iir_delay_size = 0;
audio/eq_iir/eq_iir_generic.c:	cd->iir_delay = rzalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM,
audio/eq_iir/eq_iir_generic.c:	if (!cd->iir_delay) {
audio/eq_iir/eq_iir_generic.c:	cd->iir_delay_size = delay_size;
audio/eq_iir/eq_iir_generic.c:	eq_iir_init_delay(cd->iir, cd->iir_delay, nch);
audio/eq_iir/eq_iir_ipc3.c:			filter = &cd->iir[i];
audio/eq_iir/eq_iir_ipc3.c:			filter = &cd->iir[i];
audio/eq_iir/eq_iir_ipc3.c:	} else if (cd->iir_delay_size) {
audio/eq_iir/eq_iir_ipc3.c:		cd->eq_iir_func = eq_iir_find_func(source_format, sink_format, fm_configured,
audio/eq_iir/eq_iir_ipc3.c:		cd->eq_iir_func = eq_iir_find_func(source_format, sink_format, fm_passthrough,
audio/eq_iir/eq_iir_ipc3.c:	cd->eq_iir_func = eq_iir_find_func(source_format, sink_format, fm_passthrough,
audio/eq_iir/eq_iir_ipc4.c:	} else if (cd->iir_delay_size) {
audio/eq_iir/eq_iir_ipc4.c:		cd->eq_iir_func = eq_iir_find_func(mod);
audio/eq_iir/eq_iir_ipc4.c:		cd->eq_iir_func = eq_iir_pass;
audio/eq_iir/eq_iir_ipc4.c:	cd->eq_iir_func = eq_iir_pass;
audio/google/google_hotword_detect.c:	ipc_msg_send(cd->msg, &cd->event, true);
audio/google/google_hotword_detect.c:	cd->client_data.r_ptr = NULL;
audio/google/google_hotword_detect.c:	cd->client_data.sink = NULL;
audio/google/google_hotword_detect.c:	cd->client_data.id = 0;
audio/google/google_hotword_detect.c:	cd->event_data.event_id = KPB_EVENT_BEGIN_DRAINING;
audio/google/google_hotword_detect.c:	cd->event_data.client_data = &cd->client_data;
audio/google/google_hotword_detect.c:		       NOTIFIER_TARGET_CORE_ALL_MASK, &cd->event_data,
audio/google/google_hotword_detect.c:		       sizeof(cd->event_data));
audio/google/google_hotword_detect.c:	ipc_build_comp_event(&cd->event, dev->ipc_config.type, dev->ipc_config.id);
audio/google/google_hotword_detect.c:	cd->event.event_type = SOF_CTRL_EVENT_KD;
audio/google/google_hotword_detect.c:	cd->event.num_elems = 0;
audio/google/google_hotword_detect.c:	cd->msg = ipc_msg_init(cd->event.rhdr.hdr.cmd, cd->event.rhdr.hdr.size);
audio/google/google_hotword_detect.c:	if (!cd->msg) {
audio/google/google_hotword_detect.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/google/google_hotword_detect.c:	if (!cd->model_handler) {
audio/google/google_hotword_detect.c:	comp_data_blob_handler_free(cd->model_handler);
audio/google/google_hotword_detect.c:	ipc_msg_free(cd->msg);
audio/google/google_hotword_detect.c:	comp_data_blob_handler_free(cd->model_handler);
audio/google/google_hotword_detect.c:	ipc_msg_free(cd->msg);
audio/google/google_hotword_detect.c:	model = comp_get_data_blob(cd->model_handler, &size, NULL);
audio/google/google_hotword_detect.c:	cd->detected = 0;
audio/google/google_hotword_detect.c:	cd->history_bytes = 0;
audio/google/google_hotword_detect.c:		ret = comp_data_blob_set_cmd(cd->model_handler, cdata);
audio/google/google_hotword_detect.c:		ret = comp_data_blob_get_cmd(cd->model_handler,
audio/google/google_hotword_detect.c:		cd->detected = 0;
audio/google/google_hotword_detect.c:		cd->history_bytes = 0;
audio/google/google_hotword_detect.c:	if (cd->detected)
audio/google/google_hotword_detect.c:	if (cd->history_bytes <
audio/google/google_hotword_detect.c:		cd->history_bytes += bytes;
audio/google/google_hotword_detect.c:		cd->detected = 1;
audio/google/google_hotword_detect.c:		cd->client_data.drain_req =
audio/google/google_hotword_detect.c:			    (cd->history_bytes / sample_bytes) /
audio/google/google_hotword_detect.c:			  cd->client_data.drain_req);
audio/google/google_hotword_detect.c:	if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/google/google_hotword_detect.c:	cd->detected = 0;
audio/google/google_hotword_detect.c:	cd->history_bytes = 0;
audio/google/google_rtc_audio_processing.c:	if (!comp_is_current_data_blob_valid(cd->tuning_handler) &&
audio/google/google_rtc_audio_processing.c:	    !comp_is_new_data_blob_available(cd->tuning_handler)) {
audio/google/google_rtc_audio_processing.c:	config = comp_get_data_blob(cd->tuning_handler, &size, NULL);
audio/google/google_rtc_audio_processing.c:	cd->reconfigure = false;
audio/google/google_rtc_audio_processing.c:		ret = GoogleRtcAudioProcessingReconfigure(cd->state,
audio/google/google_rtc_audio_processing.c:			cd->num_capture_channels = num_capture_input_channels;
audio/google/google_rtc_audio_processing.c:			cd->num_capture_channels = num_capture_output_channels;
audio/google/google_rtc_audio_processing.c:			cd->num_capture_channels = num_capture_output_channels;
audio/google/google_rtc_audio_processing.c:			  cd->num_capture_channels);
audio/google/google_rtc_audio_processing.c:		ret = GoogleRtcAudioProcessingSetStreamFormats(cd->state,
audio/google/google_rtc_audio_processing.c:							       cd->num_capture_channels,
audio/google/google_rtc_audio_processing.c:							       cd->num_capture_channels,
audio/google/google_rtc_audio_processing.c:							       cd->num_aec_reference_channels);
audio/google/google_rtc_audio_processing.c:		ret = GoogleRtcAudioProcessingParameters(cd->state,
audio/google/google_rtc_audio_processing.c:		ret = comp_data_blob_set_cmd(cd->tuning_handler, cdata);
audio/google/google_rtc_audio_processing.c:		if (comp_is_new_data_blob_available(cd->tuning_handler)) {
audio/google/google_rtc_audio_processing.c:			comp_get_data_blob(cd->tuning_handler, NULL, NULL);
audio/google/google_rtc_audio_processing.c:			cd->reconfigure = true;
audio/google/google_rtc_audio_processing.c:		return comp_data_blob_get_cmd(cd->tuning_handler, cdata, max_data_size);
audio/google/google_rtc_audio_processing.c:	ret = comp_data_blob_set(cd->tuning_handler, pos, data_offset_size,
audio/google/google_rtc_audio_processing.c:	if (comp_is_new_data_blob_available(cd->tuning_handler)) {
audio/google/google_rtc_audio_processing.c:		comp_get_data_blob(cd->tuning_handler, NULL, NULL);
audio/google/google_rtc_audio_processing.c:		cd->reconfigure = true;
audio/google/google_rtc_audio_processing.c:	cd->config.output_fmt = mod->priv.cfg.input_pins[SOF_AEC_DMIC_QUEUE_ID].audio_fmt;
audio/google/google_rtc_audio_processing.c:	cd->config.reference_fmt = mod->priv.cfg.input_pins[SOF_AEC_FEEDBACK_QUEUE_ID].audio_fmt;
audio/google/google_rtc_audio_processing.c:	cd->num_aec_reference_channels = cd->config.reference_fmt.channels_count;
audio/google/google_rtc_audio_processing.c:	cd->num_capture_channels = cd->config.output_fmt.channels_count;
audio/google/google_rtc_audio_processing.c:	if (cd->num_capture_channels > CONFIG_COMP_GOOGLE_RTC_AUDIO_PROCESSING_CHANNEL_MAX)
audio/google/google_rtc_audio_processing.c:		cd->num_capture_channels = CONFIG_COMP_GOOGLE_RTC_AUDIO_PROCESSING_CHANNEL_MAX;
audio/google/google_rtc_audio_processing.c:	if (cd->num_aec_reference_channels > CONFIG_COMP_GOOGLE_RTC_AUDIO_REFERENCE_CHANNEL_MAX)
audio/google/google_rtc_audio_processing.c:		cd->num_aec_reference_channels = CONFIG_COMP_GOOGLE_RTC_AUDIO_REFERENCE_CHANNEL_MAX;
audio/google/google_rtc_audio_processing.c:	cd->num_aec_reference_channels = CONFIG_COMP_GOOGLE_RTC_AUDIO_REFERENCE_CHANNEL_MAX;
audio/google/google_rtc_audio_processing.c:	cd->num_capture_channels = CONFIG_COMP_GOOGLE_RTC_AUDIO_PROCESSING_CHANNEL_MAX;
audio/google/google_rtc_audio_processing.c:	cd->tuning_handler = comp_data_blob_handler_new(dev);
audio/google/google_rtc_audio_processing.c:	if (!cd->tuning_handler) {
audio/google/google_rtc_audio_processing.c:	cd->num_frames = CONFIG_COMP_GOOGLE_RTC_AUDIO_PROCESSING_SAMPLE_RATE_HZ /
audio/google/google_rtc_audio_processing.c:		cd->memory_buffer = rballoc(0, SOF_MEM_CAPS_RAM,
audio/google/google_rtc_audio_processing.c:					    sizeof(cd->memory_buffer[0]));
audio/google/google_rtc_audio_processing.c:		if (!cd->memory_buffer) {
audio/google/google_rtc_audio_processing.c:		GoogleRtcAudioProcessingAttachMemoryBuffer(cd->memory_buffer, CONFIG_COMP_GOOGLE_RTC_AUDIO_PROCESSING_MEMORY_BUFFER_SIZE_BYTES);
audio/google/google_rtc_audio_processing.c:	cd->state = GoogleRtcAudioProcessingCreateWithConfig(CONFIG_COMP_GOOGLE_RTC_AUDIO_PROCESSING_SAMPLE_RATE_HZ,
audio/google/google_rtc_audio_processing.c:							     cd->num_capture_channels,
audio/google/google_rtc_audio_processing.c:							     cd->num_capture_channels,
audio/google/google_rtc_audio_processing.c:							     cd->num_aec_reference_channels,
audio/google/google_rtc_audio_processing.c:	if (!cd->state) {
audio/google/google_rtc_audio_processing.c:	ret = GoogleRtcAudioProcessingParameters(cd->state,
audio/google/google_rtc_audio_processing.c:	size_t buf_size = cd->num_frames * cd->num_capture_channels * sizeof(cd->process_buffer[0]);
audio/google/google_rtc_audio_processing.c:	cd->process_buffer = rballoc(0, SOF_MEM_CAPS_RAM, buf_size);
audio/google/google_rtc_audio_processing.c:	if (!cd->process_buffer) {
audio/google/google_rtc_audio_processing.c:	bzero(cd->process_buffer, buf_size);
audio/google/google_rtc_audio_processing.c:	buf_size = cd->num_frames * sizeof(cd->aec_reference_buffer[0]) *
audio/google/google_rtc_audio_processing.c:			cd->num_aec_reference_channels;
audio/google/google_rtc_audio_processing.c:	cd->aec_reference_buffer = rballoc(0, SOF_MEM_CAPS_RAM, buf_size);
audio/google/google_rtc_audio_processing.c:	if (!cd->aec_reference_buffer) {
audio/google/google_rtc_audio_processing.c:	bzero(cd->aec_reference_buffer, buf_size);
audio/google/google_rtc_audio_processing.c:	for (size_t channel = 0; channel < cd->num_capture_channels; channel++)
audio/google/google_rtc_audio_processing.c:		cd->process_buffer_ptrs[channel] = &cd->process_buffer[channel * cd->num_frames];
audio/google/google_rtc_audio_processing.c:	for (size_t channel = 0; channel < cd->num_aec_reference_channels; channel++)
audio/google/google_rtc_audio_processing.c:		cd->aec_reference_buffer_ptrs[channel] =
audio/google/google_rtc_audio_processing.c:			&cd->aec_reference_buffer[channel * cd->num_frames];
audio/google/google_rtc_audio_processing.c:	cd->raw_mic_buffer = rballoc(
audio/google/google_rtc_audio_processing.c:		cd->num_frames * cd->num_capture_channels * sizeof(cd->raw_mic_buffer[0]));
audio/google/google_rtc_audio_processing.c:	if (!cd->raw_mic_buffer) {
audio/google/google_rtc_audio_processing.c:	bzero(cd->raw_mic_buffer, cd->num_frames * cd->num_capture_channels * sizeof(cd->raw_mic_buffer[0]));
audio/google/google_rtc_audio_processing.c:	cd->raw_mic_buffer_frame_index = 0;
audio/google/google_rtc_audio_processing.c:	cd->aec_reference_buffer = rballoc(
audio/google/google_rtc_audio_processing.c:		cd->num_frames * sizeof(cd->aec_reference_buffer[0]) *
audio/google/google_rtc_audio_processing.c:		cd->num_aec_reference_channels);
audio/google/google_rtc_audio_processing.c:	if (!cd->aec_reference_buffer) {
audio/google/google_rtc_audio_processing.c:	bzero(cd->aec_reference_buffer, cd->num_frames * cd->num_aec_reference_channels * sizeof(cd->aec_reference_buffer[0]));
audio/google/google_rtc_audio_processing.c:	cd->aec_reference_frame_index = 0;
audio/google/google_rtc_audio_processing.c:	cd->output_buffer = rballoc(
audio/google/google_rtc_audio_processing.c:		cd->num_frames * cd->num_capture_channels * sizeof(cd->output_buffer[0]));
audio/google/google_rtc_audio_processing.c:	if (!cd->output_buffer) {
audio/google/google_rtc_audio_processing.c:	bzero(cd->output_buffer, cd->num_frames * sizeof(cd->output_buffer[0]));
audio/google/google_rtc_audio_processing.c:	cd->output_buffer_frame_index = 0;
audio/google/google_rtc_audio_processing.c:	cd->reconfigure = true;
audio/google/google_rtc_audio_processing.c:		rfree(cd->output_buffer);
audio/google/google_rtc_audio_processing.c:		rfree(cd->aec_reference_buffer);
audio/google/google_rtc_audio_processing.c:		if (cd->state) {
audio/google/google_rtc_audio_processing.c:			GoogleRtcAudioProcessingFree(cd->state);
audio/google/google_rtc_audio_processing.c:		rfree(cd->memory_buffer);
audio/google/google_rtc_audio_processing.c:		rfree(cd->process_buffer);
audio/google/google_rtc_audio_processing.c:		rfree(cd->raw_mic_buffer);
audio/google/google_rtc_audio_processing.c:		comp_data_blob_handler_free(cd->tuning_handler);
audio/google/google_rtc_audio_processing.c:	GoogleRtcAudioProcessingFree(cd->state);
audio/google/google_rtc_audio_processing.c:	cd->state = NULL;
audio/google/google_rtc_audio_processing.c:	rfree(cd->output_buffer);
audio/google/google_rtc_audio_processing.c:	rfree(cd->aec_reference_buffer);
audio/google/google_rtc_audio_processing.c:	rfree(cd->memory_buffer);
audio/google/google_rtc_audio_processing.c:		rfree(cd->process_buffer);
audio/google/google_rtc_audio_processing.c:		rfree(cd->raw_mic_buffer);
audio/google/google_rtc_audio_processing.c:	comp_data_blob_handler_free(cd->tuning_handler);
audio/google/google_rtc_audio_processing.c:			cd->aec_reference_source = i;
audio/google/google_rtc_audio_processing.c:			cd->raw_microphone_source = i;
audio/google/google_rtc_audio_processing.c:	ipc4_update_source_format(sources[cd->aec_reference_source], &cd->config.reference_fmt);
audio/google/google_rtc_audio_processing.c:	ipc4_update_source_format(sources[cd->raw_microphone_source], &cd->config.output_fmt);
audio/google/google_rtc_audio_processing.c:	ipc4_update_sink_format(sinks[0], &cd->config.output_fmt);
audio/google/google_rtc_audio_processing.c:			cd->aec_reference_source = i;
audio/google/google_rtc_audio_processing.c:			cd->raw_microphone_source = i;
audio/google/google_rtc_audio_processing.c:	if (cd->num_aec_reference_channels > aec_channels) {
audio/google/google_rtc_audio_processing.c:	if (cd->num_capture_channels > microphone_stream_channels) {
audio/google/google_rtc_audio_processing.c:	if (cd->num_capture_channels > output_stream_channels) {
audio/google/google_rtc_audio_processing.c:	if (cd->num_frames * source_get_frame_bytes(sources[cd->raw_microphone_source]) !=
audio/google/google_rtc_audio_processing.c:	    source_get_min_available(sources[cd->raw_microphone_source])) {
audio/google/google_rtc_audio_processing.c:			 source_get_min_available(sources[cd->raw_microphone_source]),
audio/google/google_rtc_audio_processing.c:			 cd->num_frames *
audio/google/google_rtc_audio_processing.c:				 source_get_frame_bytes(sources[cd->raw_microphone_source]));
audio/google/google_rtc_audio_processing.c:	if (cd->num_frames * sink_get_frame_bytes(sinks[0]) !=
audio/google/google_rtc_audio_processing.c:			 cd->num_frames * sink_get_frame_bytes(sinks[0]));
audio/google/google_rtc_audio_processing.c:	if (cd->num_frames * source_get_frame_bytes(sources[cd->aec_reference_source]) !=
audio/google/google_rtc_audio_processing.c:	    source_get_min_available(sources[cd->aec_reference_source])) {
audio/google/google_rtc_audio_processing.c:			 source_get_min_available(sources[cd->aec_reference_source]),
audio/google/google_rtc_audio_processing.c:			 cd->num_frames *
audio/google/google_rtc_audio_processing.c:			   source_get_frame_bytes(sources[cd->aec_reference_source]));
audio/google/google_rtc_audio_processing.c:	if (cd->reconfigure) {
audio/google/google_rtc_audio_processing.c:	src_stream = sources[cd->raw_microphone_source];
audio/google/google_rtc_audio_processing.c:	ref_stream = sources[cd->aec_reference_source];
audio/google/google_rtc_audio_processing.c:	num_of_bytes_to_process = cd->num_frames * source_get_frame_bytes(ref_stream);
audio/google/google_rtc_audio_processing.c:	for (int i = 0; i < cd->num_frames; i++) {
audio/google/google_rtc_audio_processing.c:		for (channel = 0; channel < cd->num_aec_reference_channels; ++channel) {
audio/google/google_rtc_audio_processing.c:			cd->aec_reference_buffer_ptrs[channel][i] =
audio/google/google_rtc_audio_processing.c:			cd->aec_reference_buffer[buffer_offset++] = ref[channel];
audio/google/google_rtc_audio_processing.c:		ref += cd->num_aec_reference_channels;
audio/google/google_rtc_audio_processing.c:	GoogleRtcAudioProcessingAnalyzeRender_float32(cd->state,
audio/google/google_rtc_audio_processing.c:							cd->aec_reference_buffer_ptrs);
audio/google/google_rtc_audio_processing.c:	GoogleRtcAudioProcessingAnalyzeRender_int16(cd->state,
audio/google/google_rtc_audio_processing.c:						    (const int16_t *)cd->aec_reference_buffer);
audio/google/google_rtc_audio_processing.c:	num_of_bytes_to_process = cd->num_frames * source_get_frame_bytes(src_stream);
audio/google/google_rtc_audio_processing.c:	for (int i = 0; i < cd->num_frames; i++) {
audio/google/google_rtc_audio_processing.c:		for (channel = 0; channel < cd->num_capture_channels; channel++)
audio/google/google_rtc_audio_processing.c:		cd->process_buffer_ptrs[channel][i] = convert_int16_to_float(src[channel]);
audio/google/google_rtc_audio_processing.c:		cd->process_buffer[buffer_offset++] = src[channel];
audio/google/google_rtc_audio_processing.c:		 * number of incoming channels may be < cd->num_capture_channels
audio/google/google_rtc_audio_processing.c:		src += cd->config.output_fmt.channels_count;
audio/google/google_rtc_audio_processing.c:	GoogleRtcAudioProcessingProcessCapture_float32(cd->state,
audio/google/google_rtc_audio_processing.c:						       (const float **)cd->process_buffer_ptrs,
audio/google/google_rtc_audio_processing.c:						       cd->process_buffer_ptrs);
audio/google/google_rtc_audio_processing.c:	GoogleRtcAudioProcessingProcessCapture_int16(cd->state,
audio/google/google_rtc_audio_processing.c:						     (const int16_t *)cd->process_buffer,
audio/google/google_rtc_audio_processing.c:						     cd->process_buffer);
audio/google/google_rtc_audio_processing.c:	for (int i = 0; i < cd->num_frames; i++) {
audio/google/google_rtc_audio_processing.c:		for (channel = 0; channel < cd->config.output_fmt.channels_count; channel++) {
audio/google/google_rtc_audio_processing.c:			if (channel < cd->num_capture_channels)
audio/google/google_rtc_audio_processing.c:						   cd->process_buffer_ptrs[channel][i]);
audio/google/google_rtc_audio_processing.c:				dst[channel] = cd->process_buffer[buffer_offset++];
audio/google/google_rtc_audio_processing.c:		dst += cd->config.output_fmt.channels_count;
audio/google/google_rtc_audio_processing.c:	if (cd->reconfigure) {
audio/google/google_rtc_audio_processing.c:	ref_streamb = &input_buffers[cd->aec_reference_source];
audio/google/google_rtc_audio_processing.c:	num_aec_reference_frames = input_buffers[cd->aec_reference_source].size;
audio/google/google_rtc_audio_processing.c:		for (i = 0; i < n; i += cd->num_aec_reference_channels) {
audio/google/google_rtc_audio_processing.c:			j = cd->num_aec_reference_channels * cd->aec_reference_frame_index;
audio/google/google_rtc_audio_processing.c:			for (channel = 0; channel < cd->num_aec_reference_channels; ++channel)
audio/google/google_rtc_audio_processing.c:				cd->aec_reference_buffer[j++] = ref[channel];
audio/google/google_rtc_audio_processing.c:			++cd->aec_reference_frame_index;
audio/google/google_rtc_audio_processing.c:			if (cd->aec_reference_frame_index == cd->num_frames) {
audio/google/google_rtc_audio_processing.c:				GoogleRtcAudioProcessingAnalyzeRender_int16(cd->state,
audio/google/google_rtc_audio_processing.c:									    cd->aec_reference_buffer);
audio/google/google_rtc_audio_processing.c:				cd->aec_reference_frame_index = 0;
audio/google/google_rtc_audio_processing.c:	input_buffers[cd->aec_reference_source].consumed = num_aec_reference_bytes;
audio/google/google_rtc_audio_processing.c:	mic_streamb = &input_buffers[cd->raw_microphone_source];
audio/google/google_rtc_audio_processing.c:	frames = input_buffers[cd->raw_microphone_source].size;
audio/google/google_rtc_audio_processing.c:			memcpy_s(&(cd->raw_mic_buffer[cd->raw_mic_buffer_frame_index *
audio/google/google_rtc_audio_processing.c:						      cd->num_capture_channels]),
audio/google/google_rtc_audio_processing.c:				 cd->num_frames * cd->num_capture_channels *
audio/google/google_rtc_audio_processing.c:				 sizeof(cd->raw_mic_buffer[0]), src,
audio/google/google_rtc_audio_processing.c:				 sizeof(int16_t) * cd->num_capture_channels);
audio/google/google_rtc_audio_processing.c:			++cd->raw_mic_buffer_frame_index;
audio/google/google_rtc_audio_processing.c:			memcpy_s(dst, cd->num_frames * cd->num_capture_channels *
audio/google/google_rtc_audio_processing.c:				 sizeof(cd->output_buffer[0]),
audio/google/google_rtc_audio_processing.c:				 &(cd->output_buffer[cd->output_buffer_frame_index *
audio/google/google_rtc_audio_processing.c:						     cd->num_capture_channels]),
audio/google/google_rtc_audio_processing.c:				 sizeof(int16_t) * cd->num_capture_channels);
audio/google/google_rtc_audio_processing.c:			++cd->output_buffer_frame_index;
audio/google/google_rtc_audio_processing.c:			if (cd->raw_mic_buffer_frame_index == cd->num_frames) {
audio/google/google_rtc_audio_processing.c:				GoogleRtcAudioProcessingProcessCapture_int16(cd->state,
audio/google/google_rtc_audio_processing.c:									     cd->raw_mic_buffer,
audio/google/google_rtc_audio_processing.c:									     cd->output_buffer);
audio/google/google_rtc_audio_processing.c:				cd->output_buffer_frame_index = 0;
audio/google/google_rtc_audio_processing.c:				cd->raw_mic_buffer_frame_index = 0;
audio/google/google_rtc_audio_processing.c:	module_update_buffer_position(&input_buffers[cd->raw_microphone_source],
audio/igo_nr/igo_nr.c:	if (!cd->process_enable[cd->config.active_channel_idx] ||
audio/igo_nr/igo_nr.c:	    cd->invalid_param ||
audio/igo_nr/igo_nr.c:	    cd->config.igo_params.nr_bypass == 1) {
audio/igo_nr/igo_nr.c:		memcpy_s(cd->out, IGO_FRAME_SIZE * sizeof(int16_t),
audio/igo_nr/igo_nr.c:			 cd->in, IGO_FRAME_SIZE * sizeof(int16_t));
audio/igo_nr/igo_nr.c:		IgoLibProcess(cd->p_handle,
audio/igo_nr/igo_nr.c:			      &cd->igo_stream_data_in,
audio/igo_nr/igo_nr.c:			      &cd->igo_stream_data_ref,
audio/igo_nr/igo_nr.c:			      &cd->igo_stream_data_out);
audio/igo_nr/igo_nr.c:	int32_t dbg_en = cd->config.igo_params.dump_data == 1 && nch > 1;
audio/igo_nr/igo_nr.c:	if (cd->config.active_channel_idx >= nch)
audio/igo_nr/igo_nr.c:		dbg_ch_idx = cd->config.active_channel_idx + 1;
audio/igo_nr/igo_nr.c:				if (k == cd->config.active_channel_idx)
audio/igo_nr/igo_nr.c:					cd->in[i] = sample;
audio/igo_nr/igo_nr.c:				if (k == cd->config.active_channel_idx)
audio/igo_nr/igo_nr.c:					*y2 = cd->out[i];
audio/igo_nr/igo_nr.c:					*y2 = cd->in[i];
audio/igo_nr/igo_nr.c:	int32_t dbg_en = cd->config.igo_params.dump_data == 1 && nch > 1;
audio/igo_nr/igo_nr.c:	if (cd->config.active_channel_idx >= nch)
audio/igo_nr/igo_nr.c:		dbg_ch_idx = cd->config.active_channel_idx + 1;
audio/igo_nr/igo_nr.c:				if (k == cd->config.active_channel_idx)
audio/igo_nr/igo_nr.c:					cd->in[i] = sat_int16(Q_SHIFT_RND(*x, 23, 15));
audio/igo_nr/igo_nr.c:				if (k == cd->config.active_channel_idx)
audio/igo_nr/igo_nr.c:					*y2 = cd->out[i] << 8;
audio/igo_nr/igo_nr.c:					*y2 = cd->in[i] << 8;
audio/igo_nr/igo_nr.c:	int32_t dbg_en = cd->config.igo_params.dump_data == 1 && nch > 1;
audio/igo_nr/igo_nr.c:	if (cd->config.active_channel_idx >= nch)
audio/igo_nr/igo_nr.c:		dbg_ch_idx = cd->config.active_channel_idx + 1;
audio/igo_nr/igo_nr.c:				if (k == cd->config.active_channel_idx)
audio/igo_nr/igo_nr.c:					cd->in[i] = sat_int16(Q_SHIFT_RND(*x, 31, 15));
audio/igo_nr/igo_nr.c:				if (k == cd->config.active_channel_idx)
audio/igo_nr/igo_nr.c:					*y2 = cd->out[i] << 16;
audio/igo_nr/igo_nr.c:					*y2 = cd->in[i] << 16;
audio/igo_nr/igo_nr.c:		cd->igo_nr_func = igo_nr_capture_s16;
audio/igo_nr/igo_nr.c:		cd->igo_nr_func = igo_nr_capture_s24;
audio/igo_nr/igo_nr.c:		cd->igo_nr_func = igo_nr_capture_s32;
audio/igo_nr/igo_nr.c:	ret = IgoLibGetInfo(&cd->igo_lib_info);
audio/igo_nr/igo_nr.c:	cd->p_handle = rballoc(0, SOF_MEM_CAPS_RAM, cd->igo_lib_info.handle_size);
audio/igo_nr/igo_nr.c:	if (!cd->p_handle) {
audio/igo_nr/igo_nr.c:			 cd->igo_lib_info.handle_size);
audio/igo_nr/igo_nr.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/igo_nr/igo_nr.c:	if (!cd->model_handler) {
audio/igo_nr/igo_nr.c:	ret = comp_init_data_blob(cd->model_handler, bs, cfg->data);
audio/igo_nr/igo_nr.c:	comp_data_blob_handler_free(cd->model_handler);
audio/igo_nr/igo_nr.c:	rfree(cd->p_handle);
audio/igo_nr/igo_nr.c:	comp_data_blob_handler_free(cd->model_handler);
audio/igo_nr/igo_nr.c:	rfree(cd->p_handle);
audio/igo_nr/igo_nr.c:	cd->source_rate = source_get_rate(source);
audio/igo_nr/igo_nr.c:	cd->sink_rate = sink_get_rate(sink);
audio/igo_nr/igo_nr.c:		cd->invalid_param = true;
audio/igo_nr/igo_nr.c:	if (!cd->sink_rate) {
audio/igo_nr/igo_nr.c:	switch (cd->source_rate) {
audio/igo_nr/igo_nr.c:		cd->invalid_param = false;
audio/igo_nr/igo_nr.c:		cd->invalid_param = true;
audio/igo_nr/igo_nr.c:	return cd->invalid_param ? -EINVAL : 0;
audio/igo_nr/igo_nr.c:	struct sof_igo_nr_config *p_config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/igo_nr/igo_nr.c:		comp_err(dev, "igo_nr_check_config_validity() error: invalid cd->model_handler");
audio/igo_nr/igo_nr.c:	if (!cd->process_enable[chan])
audio/igo_nr/igo_nr.c:		cd->process_enable[chan] = true;
audio/igo_nr/igo_nr.c:	if (cd->process_enable[chan]) {
audio/igo_nr/igo_nr.c:		cd->process_enable[chan] = false;
audio/igo_nr/igo_nr.c:		IgoLibInit(cd->p_handle, &cd->igo_lib_config, &cd->config.igo_params);
audio/igo_nr/igo_nr.c:		return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/igo_nr/igo_nr.c:			cdata->chanv[j].value = cd->process_enable[j];
audio/igo_nr/igo_nr.c:		ret = comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/igo_nr/igo_nr.c:	ret = comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment, fragment_size);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.igo_params_ver);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.dump_data);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_bypass);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode1_en);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode3_en);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_ul_enable);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.agc_gain);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_voice_str);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_level);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode1_floor);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode1_od);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode1_pp_param7);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode1_pp_param8);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode1_pp_param10);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode3_floor);
audio/igo_nr/igo_nr.c:		 cd->config.igo_params.nr_mode1_pp_param53);
audio/igo_nr/igo_nr.c:		 cd->config.active_channel_idx);
audio/igo_nr/igo_nr.c:	struct sof_igo_nr_config *p_config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/igo_nr/igo_nr.c:		cd->config = *p_config;
audio/igo_nr/igo_nr.c:	if (comp_is_new_data_blob_available(cd->model_handler))
audio/igo_nr/igo_nr.c:	ret = cd->igo_nr_func(cd, source, sink, IGO_FRAME_SIZE);
audio/igo_nr/igo_nr.c:	cd->igo_lib_config.algo_name = "igo_nr";
audio/igo_nr/igo_nr.c:	cd->igo_lib_config.in_ch_num = 1;
audio/igo_nr/igo_nr.c:	cd->igo_lib_config.ref_ch_num = 0;
audio/igo_nr/igo_nr.c:	cd->igo_lib_config.out_ch_num = 1;
audio/igo_nr/igo_nr.c:	IgoLibInit(cd->p_handle, &cd->igo_lib_config, &cd->config.igo_params);
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_in.data = cd->in;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_in.data_width = IGO_DATA_16BIT;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_in.sample_num = IGO_FRAME_SIZE;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_in.sampling_rate = 48000;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_ref.data = NULL;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_ref.data_width = 0;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_ref.sample_num = 0;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_ref.sampling_rate = 0;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_out.data = cd->out;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_out.data_width = IGO_DATA_16BIT;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_out.sample_num = IGO_FRAME_SIZE;
audio/igo_nr/igo_nr.c:	cd->igo_stream_data_out.sampling_rate = 48000;
audio/igo_nr/igo_nr.c:	memset(cd->in, 0, IGO_NR_IN_BUF_LENGTH * sizeof(int16_t));
audio/igo_nr/igo_nr.c:	memset(cd->out, 0, IGO_NR_OUT_BUF_LENGTH * sizeof(int16_t));
audio/igo_nr/igo_nr.c:	cd->process_enable[cd->config.active_channel_idx] = true;
audio/igo_nr/igo_nr.c:	cd->igo_nr_func = NULL;
audio/igo_nr/igo_nr.c:	cd->source_rate = 0;
audio/igo_nr/igo_nr.c:	cd->sink_rate = 0;
audio/igo_nr/igo_nr.c:	cd->invalid_param = false;
audio/mfcc/mfcc.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/mfcc/mfcc.c:	if (!cd->model_handler) {
audio/mfcc/mfcc.c:	ret = comp_init_data_blob(cd->model_handler, bs, cfg->init_data);
audio/mfcc/mfcc.c:	comp_data_blob_handler_free(cd->model_handler);
audio/mfcc/mfcc.c:	comp_data_blob_handler_free(cd->model_handler);
audio/mfcc/mfcc.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/mfcc/mfcc.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/mfcc/mfcc.c:	frames = MIN(frames, cd->max_frames);
audio/mfcc/mfcc.c:	cd->mfcc_func(mod, input_buffers, output_buffers, frames);
audio/mfcc/mfcc.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/mfcc/mfcc.c:	if (cd->config) {
audio/mfcc/mfcc.c:	cd->mfcc_func = mfcc_find_func(source_format, sink_format, mfcc_fm, ARRAY_SIZE(mfcc_fm));
audio/mfcc/mfcc.c:	if (!cd->mfcc_func) {
audio/mfcc/mfcc.c:	cd->mfcc_func = NULL;
audio/mfcc/mfcc_common.c:	struct mfcc_state *state = &cd->state;
audio/mfcc/mfcc_common.c:	struct mfcc_buffer *buf = &cd->state.buf;
audio/mfcc/mfcc_setup.c:	struct sof_mfcc_config *config = cd->config;
audio/mfcc/mfcc_setup.c:	struct mfcc_state *state = &cd->state;
audio/mfcc/mfcc_setup.c:	cd->max_frames = max_frames;
audio/mfcc/mfcc_setup.c:	fft_plan_free(cd->state.fft.fft_plan);
audio/mfcc/mfcc_setup.c:	rfree(cd->state.fft.fft_buf);
audio/mfcc/mfcc_setup.c:	rfree(cd->state.fft.fft_out);
audio/mfcc/mfcc_setup.c:	rfree(cd->state.buffers);
audio/mfcc/mfcc_setup.c:	rfree(cd->state.melfb.data);
audio/mfcc/mfcc_setup.c:	rfree(cd->state.dct.matrix);
audio/mfcc/mfcc_setup.c:	rfree(cd->state.lifter.matrix);
audio/module_adapter/module/cadence.c:	cd->api = api;
audio/module_adapter/module/cadence.c:	cd->api_id = api_id;
audio/module_adapter/module/cadence.c:	cd->api = api;
audio/module_adapter/module/cadence.c:	cd->api_id = api_id;
audio/module_adapter/module/cadence.c:		 XA_CMD_TYPE_LIB_NAME, cd->name, ret);
audio/module_adapter/module/cadence.c:	cd->self = rballoc(0, SOF_MEM_CAPS_RAM, obj_size);
audio/module_adapter/module/cadence.c:	if (!cd->self) {
audio/module_adapter/module/cadence.c:		rfree(cd->self);
audio/module_adapter/module/cadence.c:		setup_cfg = &cd->setup_cfg;
audio/module_adapter/module/cadence.c:		setup_cfg = &cd->setup_cfg;
audio/module_adapter/module/cadence.c:		cfg = &cd->setup_cfg;
audio/module_adapter/module/cadence.c:		if (codec_id && codec_id != cd->api_id) {
audio/module_adapter/module/cadence.c:	switch (cd->api_id) {
audio/module_adapter/module/cadence.c:	cd->mem_tabs = module_allocate_memory(mod, mem_tabs_size, 4);
audio/module_adapter/module/cadence.c:	if (!cd->mem_tabs) {
audio/module_adapter/module/cadence.c:	API_CALL(cd, XA_API_CMD_SET_MEMTABS_PTR, 0, cd->mem_tabs, ret);
audio/module_adapter/module/cadence.c:	module_free_memory(mod, cd->mem_tabs);
audio/module_adapter/module/cadence.c:	rfree(cd->self);
audio/module_adapter/module/cadence.c:	cd->self = NULL;
audio/module_adapter/module/cadence.c:	rfree(cd->setup_cfg.data);
audio/module_adapter/module/cadence.c:	rfree(cd->self);
audio/multiband_drc/multiband_drc.c:	struct sof_multiband_drc_config *config = cd->config;
audio/multiband_drc/multiband_drc.c:	struct multiband_drc_state *state = &cd->state;
audio/multiband_drc/multiband_drc.c:	uint32_t sample_bytes = get_sample_bytes(cd->source_format);
audio/multiband_drc/multiband_drc.c:					     cd->config->drc_coef[i].pre_delay_time, rate);
audio/multiband_drc/multiband_drc.c:	multiband_drc_reset_state(&cd->state);
audio/multiband_drc/multiband_drc.c:	cd->multiband_drc_func = NULL;
audio/multiband_drc/multiband_drc.c:	cd->crossover_split = NULL;
audio/multiband_drc/multiband_drc.c:	multiband_drc_process_enable(&cd->process_enabled);
audio/multiband_drc/multiband_drc.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/multiband_drc/multiband_drc.c:	if (!cd->model_handler) {
audio/multiband_drc/multiband_drc.c:	ret = comp_init_data_blob(cd->model_handler, bs, cfg->data);
audio/multiband_drc/multiband_drc.c:	multiband_drc_reset_state(&cd->state);
audio/multiband_drc/multiband_drc.c:	comp_data_blob_handler_free(cd->model_handler);
audio/multiband_drc/multiband_drc.c:	comp_data_blob_handler_free(cd->model_handler);
audio/multiband_drc/multiband_drc.c:	if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/multiband_drc/multiband_drc.c:		cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/multiband_drc/multiband_drc.c:	cd->multiband_drc_func(mod, source, sink, frames);
audio/multiband_drc/multiband_drc.c:	cd->source_format = audio_stream_get_frm_fmt(&sourceb->stream);
audio/multiband_drc/multiband_drc.c:		 cd->source_format, cd->source_format);
audio/multiband_drc/multiband_drc.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/multiband_drc/multiband_drc.c:	if (cd->config && cd->process_enabled) {
audio/multiband_drc/multiband_drc.c:		cd->multiband_drc_func = multiband_drc_find_proc_func(cd->source_format);
audio/multiband_drc/multiband_drc.c:		if (!cd->multiband_drc_func) {
audio/multiband_drc/multiband_drc.c:		cd->crossover_split = crossover_find_split_func(cd->config->num_bands);
audio/multiband_drc/multiband_drc.c:		if (!cd->crossover_split) {
audio/multiband_drc/multiband_drc.c:				 cd->config->num_bands);
audio/multiband_drc/multiband_drc.c:		cd->multiband_drc_func = multiband_drc_find_proc_func_pass(cd->source_format);
audio/multiband_drc/multiband_drc.c:		if (!cd->multiband_drc_func) {
audio/multiband_drc/multiband_drc.c:	multiband_drc_reset_state(&cd->state);
audio/multiband_drc/multiband_drc.c:	cd->source_format = 0;
audio/multiband_drc/multiband_drc.c:	cd->multiband_drc_func = NULL;
audio/multiband_drc/multiband_drc.c:	cd->crossover_split = NULL;
audio/multiband_drc/multiband_drc_generic.c:	struct multiband_drc_state *state = &cd->state;
audio/multiband_drc/multiband_drc_generic.c:	int nband = cd->config->num_bands;
audio/multiband_drc/multiband_drc_generic.c:	int enable_emp_deemp = cd->config->enable_emp_deemp;
audio/multiband_drc/multiband_drc_generic.c:			multiband_drc_process_emp_crossover(state, cd->crossover_split,
audio/multiband_drc/multiband_drc_generic.c:							      &cd->config->drc_coef[band],
audio/multiband_drc/multiband_drc_generic.c:	struct multiband_drc_state *state = &cd->state;
audio/multiband_drc/multiband_drc_generic.c:	int nband = cd->config->num_bands;
audio/multiband_drc/multiband_drc_generic.c:	int enable_emp_deemp = cd->config->enable_emp_deemp;
audio/multiband_drc/multiband_drc_generic.c:			multiband_drc_process_emp_crossover(state, cd->crossover_split,
audio/multiband_drc/multiband_drc_generic.c:							      &cd->config->drc_coef[band],
audio/multiband_drc/multiband_drc_generic.c:	struct multiband_drc_state *state = &cd->state;
audio/multiband_drc/multiband_drc_generic.c:	int nband = cd->config->num_bands;
audio/multiband_drc/multiband_drc_generic.c:	int enable_emp_deemp = cd->config->enable_emp_deemp;
audio/multiband_drc/multiband_drc_generic.c:			multiband_drc_process_emp_crossover(state, cd->crossover_split,
audio/multiband_drc/multiband_drc_generic.c:							      &cd->config->drc_coef[band],
audio/multiband_drc/multiband_drc_ipc3.c:			cd->process_enabled = cdata->chanv[0].value;
audio/multiband_drc/multiband_drc_ipc3.c:				  cd->process_enabled);
audio/multiband_drc/multiband_drc_ipc3.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment,
audio/multiband_drc/multiband_drc_ipc3.c:			cdata->chanv[j].value = cd->process_enabled;
audio/multiband_drc/multiband_drc_ipc3.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/multiband_drc/multiband_drc_ipc4.c:			cd->process_enabled = ctl->chanv[0].value;
audio/multiband_drc/multiband_drc_ipc4.c:			comp_info(dev, "process_enabled = %d", cd->process_enabled);
audio/multiband_drc/multiband_drc_ipc4.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size, fragment,
audio/multiband_drc/multiband_drc_ipc4.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/mux/mux.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/mux/mux.c:	if (!cd->model_handler) {
audio/mux/mux.c:	ret = comp_init_data_blob(cd->model_handler, cfg->size, cfg->init_data);
audio/mux/mux.c:	comp_data_blob_handler_free(cd->model_handler);
audio/mux/mux.c:	comp_data_blob_handler_free(cd->model_handler);
audio/mux/mux.c:		if (cd->config.streams[idx].pipeline_id == pipe_id)
audio/mux/mux.c:		if (cd->config.streams[i].pipeline_id == pipe_id)
audio/mux/mux.c:			return &cd->lookup[i];
audio/mux/mux.c:	for (elem = 0; elem < cd->lookup[0].num_elems; elem++) {
audio/mux/mux.c:		source = sources[cd->lookup[0].copy_elem[elem].stream_id];
audio/mux/mux.c:		if (cd->lookup[0].copy_elem[elem].in_ch >= audio_stream_get_channels(source) ||
audio/mux/mux.c:		    cd->lookup[0].copy_elem[elem].out_ch >= audio_stream_get_channels(sink))
audio/mux/mux.c:		cd->active_lookup.copy_elem[active_elem] = cd->lookup[0].copy_elem[elem];
audio/mux/mux.c:	cd->active_lookup.num_elems = active_elem;
audio/mux/mux.c:		cd->active_lookup.copy_elem[active_elem] = look_up->copy_elem[elem];
audio/mux/mux.c:	cd->active_lookup.num_elems = active_elem;
audio/mux/mux.c:			cd->demux(dev, sinks_stream[i], input_buffers[0].data,
audio/mux/mux.c:				  frames, &cd->active_lookup);
audio/mux/mux.c:	cd->mux(dev, output_buffers[0].data, &sources_stream[0], frames, &cd->active_lookup);
audio/mux/mux.c:	cd->mux = NULL;
audio/mux/mux.c:	cd->demux = NULL;
audio/mux/mux.c:	config = comp_get_data_blob(cd->model_handler, &blob_size, NULL);
audio/mux/mux.c:	memcpy_s(&cd->config, MUX_BLOB_MAX_SIZE, config, blob_size);
audio/mux/mux.c:		cd->mux = mux_get_processing_function(mod);
audio/mux/mux.c:		cd->demux = demux_get_processing_function(mod);
audio/mux/mux.c:	if (!cd->mux && !cd->demux) {
audio/mux/mux.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/mux/mux.c:	return comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/mux/mux_generic.c:	for (i = 0; i < cd->config.num_streams; i++) {
audio/mux/mux_generic.c:				if (cd->config.streams[i].mask[j] & BIT(k)) {
audio/mux/mux_generic.c:					cd->lookup[0].copy_elem[idx].in_ch = j;
audio/mux/mux_generic.c:					cd->lookup[0].copy_elem[idx].out_ch = k;
audio/mux/mux_generic.c:					cd->lookup[0].copy_elem[idx].stream_id = i;
audio/mux/mux_generic.c:					cd->lookup[0].num_elems = ++idx;
audio/mux/mux_generic.c:	for (i = 0; i < cd->config.num_streams; i++) {
audio/mux/mux_generic.c:				if (cd->config.streams[i].mask[j] & BIT(k)) {
audio/mux/mux_generic.c:					cd->lookup[i].copy_elem[idx].in_ch = k;
audio/mux/mux_generic.c:					cd->lookup[i].copy_elem[idx].out_ch = j;
audio/mux/mux_generic.c:					cd->lookup[i].copy_elem[idx].stream_id = i;
audio/mux/mux_generic.c:					cd->lookup[i].num_elems = ++idx;
audio/mux/mux_ipc3.c:	struct sof_mux_config *cfg = &cd->config;
audio/mux/mux_ipc3.c:		cd->config.streams[i].pipeline_id = cfg->streams[i].pipeline_id;
audio/mux/mux_ipc3.c:			cd->config.streams[i].mask[j] = cfg->streams[i].mask[j];
audio/mux/mux_ipc3.c:	cd->config.num_streams = cfg->num_streams;
audio/mux/mux_ipc3.c:			cd->mux = mux_get_processing_function(mod);
audio/mux/mux_ipc3.c:			cd->demux = demux_get_processing_function(mod);
audio/mux/mux_ipc4.c:	cd->config.num_streams = MUX_MAX_STREAMS;
audio/mux/mux_ipc4.c:	for (i = 0; i < cd->config.num_streams; i++)
audio/mux/mux_ipc4.c:		memset(cd->config.streams[i].mask, 0, sizeof(cd->config.streams[i].mask));
audio/mux/mux_ipc4.c:	for (i = 0; i < cd->md.base_cfg.audio_fmt.channels_count; i++) {
audio/mux/mux_ipc4.c:		cd->config.streams[0].mask[i] = mask;
audio/mux/mux_ipc4.c:	for (i = 0; i < cd->md.reference_format.channels_count; i++) {
audio/mux/mux_ipc4.c:		cd->config.streams[1].mask[i] = mask;
audio/mux/mux_ipc4.c:	if (mux_mix_check(&cd->config)) {
audio/mux/mux_ipc4.c:	params->channels =  cd->md.base_cfg.audio_fmt.channels_count;
audio/mux/mux_ipc4.c:	params->rate = cd->md.base_cfg.audio_fmt.sampling_frequency;
audio/mux/mux_ipc4.c:	params->sample_container_bytes = cd->md.base_cfg.audio_fmt.depth / 8;
audio/mux/mux_ipc4.c:	params->sample_valid_bytes = cd->md.base_cfg.audio_fmt.valid_bit_depth / 8;
audio/mux/mux_ipc4.c:	params->buffer_fmt = cd->md.base_cfg.audio_fmt.interleaving_style;
audio/mux/mux_ipc4.c:	params->buffer.size = cd->md.base_cfg.ibs;
audio/mux/mux_ipc4.c:			ipc4_update_buffer_format(sink, &cd->md.output_format);
audio/mux/mux_ipc4.c:			cd->config.streams[j].pipeline_id = source->pipeline_id;
audio/mux/mux_ipc4.c:				audio_fmt = &cd->md.base_cfg.audio_fmt;
audio/mux/mux_ipc4.c:				audio_fmt = &cd->md.reference_format;
audio/pipeline/pipeline-graph.c:		if (list_is_empty(&ipc_sink->cd->bsink_list))
audio/pipeline/pipeline-stream.c:			dd = cd->dd[0];
audio/rtnr/rtnr.c:	RTKMA_API_S16_Default(cd->rtk_agl, sources, sink, frames,
audio/rtnr/rtnr.c:	RTKMA_API_S24_Default(cd->rtk_agl, sources, sink, frames,
audio/rtnr/rtnr.c:	RTKMA_API_S32_Default(cd->rtk_agl, sources, sink, frames,
audio/rtnr/rtnr.c:	cd->process_sample_rate = sample_rate;
audio/rtnr/rtnr.c:		cd->config.params.sample_rate, cd->config.params.enabled);
audio/rtnr/rtnr.c:	if ((cd->config.params.sample_rate != 48000) &&
audio/rtnr/rtnr.c:		(cd->config.params.sample_rate != 16000)) {
audio/rtnr/rtnr.c:			cd->config.params.sample_rate);
audio/rtnr/rtnr.c:	rtnr_set_process_sample_rate(mod, cd->config.params.sample_rate);
audio/rtnr/rtnr.c:	cd->process_enable = true;
audio/rtnr/rtnr.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/rtnr/rtnr.c:	if (!cd->model_handler) {
audio/rtnr/rtnr.c:	ret = comp_init_data_blob(cd->model_handler, bs, ipc_rtnr->data);
audio/rtnr/rtnr.c:	cd->source_channel = 0;
audio/rtnr/rtnr.c:	cd->rtk_agl = RTKMA_API_Context_Create(cd->process_sample_rate);
audio/rtnr/rtnr.c:	if (cd->rtk_agl == 0) {
audio/rtnr/rtnr.c:	cd->reconfigure = true;
audio/rtnr/rtnr.c:	comp_data_blob_handler_free(cd->model_handler);
audio/rtnr/rtnr.c:	comp_data_blob_handler_free(cd->model_handler);
audio/rtnr/rtnr.c:	RTKMA_API_Context_Free(cd->rtk_agl);
audio/rtnr/rtnr.c:	cd->source_rate = audio_stream_get_rate(source);
audio/rtnr/rtnr.c:	cd->sink_rate = audio_stream_get_rate(sink);
audio/rtnr/rtnr.c:	cd->sources_stream[0].rate = audio_stream_get_rate(source);
audio/rtnr/rtnr.c:	cd->sink_stream.rate = audio_stream_get_rate(sink);
audio/rtnr/rtnr.c:	if (!cd->sink_rate) {
audio/rtnr/rtnr.c:	switch (cd->source_rate) {
audio/rtnr/rtnr.c:			 cd->source_rate);
audio/rtnr/rtnr.c:	cd->sources_stream[0].channels = audio_stream_get_channels(source);
audio/rtnr/rtnr.c:	cd->sink_stream.channels = audio_stream_get_channels(sink);
audio/rtnr/rtnr.c:	cd->sources_stream[0].overrun_permitted = audio_stream_get_overrun(source);
audio/rtnr/rtnr.c:	cd->sink_stream.overrun_permitted = audio_stream_get_overrun(sink);
audio/rtnr/rtnr.c:	cd->sources_stream[0].underrun_permitted = audio_stream_get_underrun(source);
audio/rtnr/rtnr.c:	cd->sink_stream.underrun_permitted = audio_stream_get_underrun(sink);
audio/rtnr/rtnr.c:	if (sizeof(cd->config) > max_data_size)
audio/rtnr/rtnr.c:	ret = memcpy_s(cdata->data->data, max_data_size, &cd->config, sizeof(cd->config));
audio/rtnr/rtnr.c:	cdata->data->size = sizeof(cd->config);
audio/rtnr/rtnr.c:	config = comp_get_data_blob(cd->model_handler, &size, NULL);
audio/rtnr/rtnr.c:			cdata->chanv[j].value = cd->process_enable;
audio/rtnr/rtnr.c:	if (!comp_is_current_data_blob_valid(cd->model_handler) &&
audio/rtnr/rtnr.c:	    !comp_is_new_data_blob_available(cd->model_handler)) {
audio/rtnr/rtnr.c:	config = comp_get_data_blob(cd->model_handler, &size, NULL);
audio/rtnr/rtnr.c:	cd->reconfigure = false;
audio/rtnr/rtnr.c:	RTKMA_API_Set(cd->rtk_agl, config, size, RTNR_DATA_ID_PRESET);
audio/rtnr/rtnr.c:	if (size < sizeof(cd->config)) {
audio/rtnr/rtnr.c:	ret = memcpy_s(&cd->config,
audio/rtnr/rtnr.c:		       sizeof(cd->config),
audio/rtnr/rtnr.c:		       sizeof(cd->config));
audio/rtnr/rtnr.c:		  cd->config.params.sample_rate,
audio/rtnr/rtnr.c:		  cd->config.params.enabled);
audio/rtnr/rtnr.c:		cd->process_enable = true;
audio/rtnr/rtnr.c:		cd->process_enable = false;
audio/rtnr/rtnr.c:			ret = comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/rtnr/rtnr.c:			if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/rtnr/rtnr.c:				comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/rtnr/rtnr.c:				cd->reconfigure = true;
audio/rtnr/rtnr.c:		ret = comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/rtnr/rtnr.c:		if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/rtnr/rtnr.c:			comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/rtnr/rtnr.c:			cd->reconfigure = true;
audio/rtnr/rtnr.c:	struct audio_stream_rtnr *sink_stream = &cd->sink_stream;
audio/rtnr/rtnr.c:	if (cd->reconfigure) {
audio/rtnr/rtnr.c:		sources_stream[i] = &cd->sources_stream[i];
audio/rtnr/rtnr.c:	RTKMA_API_First_Copy(cd->rtk_agl, cd->source_rate, audio_stream_get_channels(source));
audio/rtnr/rtnr.c:	if (cd->process_enable) {
audio/rtnr/rtnr.c:		cd->rtnr_func(mod, sources_stream, sink_stream, frames);
audio/rtnr/rtnr.c:		RTKMA_API_Process(cd->rtk_agl, 0, cd->source_rate, MicNum);
audio/rtnr/rtnr.c:	cd->sink_format = audio_stream_get_frm_fmt(&sinkb->stream);
audio/rtnr/rtnr.c:	cd->sink_stream.frame_fmt = audio_stream_get_frm_fmt(&sinkb->stream);
audio/rtnr/rtnr.c:	comp_info(dev, "rtnr_prepare(), sink_format=%d", cd->sink_format);
audio/rtnr/rtnr.c:	cd->rtnr_func = rtnr_find_func(cd->sink_format);
audio/rtnr/rtnr.c:	if (!cd->rtnr_func) {
audio/rtnr/rtnr.c:	RTKMA_API_Prepare(cd->rtk_agl);
audio/rtnr/rtnr.c:	cd->sink_format = 0;
audio/rtnr/rtnr.c:	cd->rtnr_func = NULL;
audio/rtnr/rtnr.c:	cd->source_rate = 0;
audio/rtnr/rtnr.c:	cd->sink_rate = 0;
audio/selector/selector.c:	 * cd->config.in_channels_count (PLAYBACK) or
audio/selector/selector.c:	 * cd->config.out_channels_count (CAPTURE) set during creating selector
audio/selector/selector.c:	 * cd->config.in/out_channels_count = 0 means that it can vary.
audio/selector/selector.c:		if (cd->config.in_channels_count &&
audio/selector/selector.c:		    cd->config.in_channels_count != params->channels) {
audio/selector/selector.c:		in_channels = cd->config.in_channels_count;
audio/selector/selector.c:		/* if cd->config.out_channels_count are equal to 0
audio/selector/selector.c:		out_channels = cd->config.out_channels_count ?
audio/selector/selector.c:			cd->config.out_channels_count : audio_stream_get_channels(&buffer->stream);
audio/selector/selector.c:		if (cd->config.out_channels_count &&
audio/selector/selector.c:		    cd->config.out_channels_count != params->channels) {
audio/selector/selector.c:		out_channels = cd->config.out_channels_count;
audio/selector/selector.c:		/* if cd->config.in_channels_count are equal to 0
audio/selector/selector.c:		in_channels = cd->config.in_channels_count ?
audio/selector/selector.c:			cd->config.in_channels_count : audio_stream_get_channels(&buffer->stream);
audio/selector/selector.c:	if (cd->config.sel_channel > (params->channels - 1)) {
audio/selector/selector.c:			 , cd->config.sel_channel);
audio/selector/selector.c:	ret = memcpy_s(&cd->config, sizeof(cd->config), ipc_process->data, bs);
audio/selector/selector.c:		cd->config.in_channels_count = cfg->in_channels_count;
audio/selector/selector.c:		cd->config.out_channels_count = cfg->out_channels_count;
audio/selector/selector.c:		cd->config.sel_channel = cfg->sel_channel;
audio/selector/selector.c:			       (cdata->data))->size, &cd->config,
audio/selector/selector.c:			       sizeof(cd->config));
audio/selector/selector.c:		cdata->data->size = sizeof(cd->config);
audio/selector/selector.c:	cd->sel_func(dev, &sink->stream, &source->stream, frames);
audio/selector/selector.c:	cd->source_format = audio_stream_get_frm_fmt(&sourceb->stream);
audio/selector/selector.c:	cd->source_period_bytes = audio_stream_period_bytes(&sourceb->stream, dev->frames);
audio/selector/selector.c:	cd->sink_format = audio_stream_get_frm_fmt(&sinkb->stream);
audio/selector/selector.c:	cd->sink_period_bytes = audio_stream_period_bytes(&sinkb->stream, dev->frames);
audio/selector/selector.c:	if (sink_size < cd->sink_period_bytes) {
audio/selector/selector.c:			 sink_size, cd->sink_period_bytes);
audio/selector/selector.c:	if (cd->sink_period_bytes == 0) {
audio/selector/selector.c:		comp_err(dev, "selector_prepare(): cd->sink_period_bytes = 0, dev->frames = %u",
audio/selector/selector.c:	if (cd->source_period_bytes == 0) {
audio/selector/selector.c:		comp_err(dev, "selector_prepare(): cd->source_period_bytes = 0, dev->frames = %u",
audio/selector/selector.c:	cd->sel_func = sel_get_processing_function(dev);
audio/selector/selector.c:	if (!cd->sel_func) {
audio/selector/selector.c:		comp_err(dev, "selector_prepare(): invalid cd->sel_func, cd->source_format = %u, cd->sink_format = %u, cd->out_channels_count = %u",
audio/selector/selector.c:			 cd->source_format, cd->sink_format,
audio/selector/selector.c:			 cd->config.out_channels_count);
audio/selector/selector.c:	cd->source_period_bytes = 0;
audio/selector/selector.c:	cd->sink_period_bytes = 0;
audio/selector/selector.c:	cd->sel_func = NULL;
audio/selector/selector.c:	const struct sof_selector_ipc4_config *sel_cfg = &cd->sel_ipc4_cfg;
audio/selector/selector.c:	if (cd->sel_ipc4_cfg.init_payload_fmt == IPC4_SEL_INIT_PAYLOAD_BASE_WITH_EXT)
audio/selector/selector.c:	cd->source_format = frame_fmt;
audio/selector/selector.c:	cd->sink_format = frame_fmt;
audio/selector/selector.c:	cd->config.in_channels_count = cfg->base_cfg.audio_fmt.channels_count;
audio/selector/selector.c:	cd->config.out_channels_count = out_fmt->channels_count;
audio/selector/selector.c:	memset(&cd->coeffs_config, 0, sizeof(cd->coeffs_config));
audio/selector/selector.c:		cd->coeffs_config.coeffs[i][i] = 1 << 10;
audio/selector/selector.c:	cd->sel_ipc4_cfg.init_payload_fmt = payload_fmt;
audio/selector/selector.c:		ret = memcpy_s(&cd->sel_ipc4_cfg.pin_cfg, size,
audio/selector/selector.c:		ret = memcpy_s(&cd->sel_ipc4_cfg.output_format, bs[1],
audio/selector/selector.c:	const struct sof_selector_ipc4_config *sel_cfg = &cd->sel_ipc4_cfg;
audio/selector/selector.c:	if (cd->sel_ipc4_cfg.init_payload_fmt == IPC4_SEL_INIT_PAYLOAD_BASE_WITH_EXT)
audio/selector/selector.c:		params->channels = cd->config.in_channels_count;
audio/selector/selector.c:		params->channels = cd->config.out_channels_count;
audio/selector/selector.c:	params->frame_fmt = cd->source_format;
audio/selector/selector.c:	uint32_t in_channels = cd->config.in_channels_count;
audio/selector/selector.c:	uint32_t out_channels = cd->config.out_channels_count;
audio/selector/selector.c:		if (data_offset_size != sizeof(cd->coeffs_config))
audio/selector/selector.c:		memcpy_s(&cd->coeffs_config, sizeof(cd->coeffs_config), fragment, data_offset_size);
audio/selector/selector.c:		cd->sel_func(mod, input_buffers, output_buffers, avail_frames);
audio/selector/selector.c:	cd->source_format = audio_stream_get_frm_fmt(&sourceb->stream);
audio/selector/selector.c:	cd->source_period_bytes = audio_stream_period_bytes(&sourceb->stream, dev->frames);
audio/selector/selector.c:	cd->sink_format = audio_stream_get_frm_fmt(&sinkb->stream);
audio/selector/selector.c:	cd->sink_period_bytes = audio_stream_period_bytes(&sinkb->stream, dev->frames);
audio/selector/selector.c:	md->mpd.in_buff_size = cd->source_period_bytes;
audio/selector/selector.c:	md->mpd.out_buff_size = cd->sink_period_bytes;
audio/selector/selector.c:	if (sink_size < cd->sink_period_bytes) {
audio/selector/selector.c:			 sink_size, cd->sink_period_bytes);
audio/selector/selector.c:	if (cd->sink_period_bytes == 0) {
audio/selector/selector.c:		comp_err(dev, "selector_prepare(): cd->sink_period_bytes = 0, dev->frames = %u",
audio/selector/selector.c:	if (cd->source_period_bytes == 0) {
audio/selector/selector.c:		comp_err(dev, "selector_prepare(): cd->source_period_bytes = 0, dev->frames = %u",
audio/selector/selector.c:	cd->sel_func = sel_get_processing_function(mod);
audio/selector/selector.c:	if (!cd->sel_func) {
audio/selector/selector.c:		comp_err(dev, "selector_prepare(): invalid cd->sel_func, cd->source_format = %u, cd->sink_format = %u, cd->out_channels_count = %u",
audio/selector/selector.c:			 cd->source_format, cd->sink_format,
audio/selector/selector.c:			 cd->config.out_channels_count);
audio/selector/selector.c:	cd->source_period_bytes = 0;
audio/selector/selector.c:	cd->sink_period_bytes = 0;
audio/selector/selector.c:	cd->sel_func = NULL;
audio/selector/selector_generic.c:	const unsigned int sel_channel = cd->config.sel_channel; /* 0 to nch - 1 */
audio/selector/selector_generic.c:	const unsigned int sel_channel = cd->config.sel_channel; /* 0 to nch - 1 */
audio/selector/selector_generic.c:					    &cd->coeffs_config);
audio/selector/selector_generic.c:					    &cd->coeffs_config);
audio/selector/selector_generic.c:		if (cd->source_format != func_table[i].source)
audio/selector/selector_generic.c:		if (cd->config.out_channels_count != func_table[i].out_channels)
audio/selector/selector_generic.c:		if (cd->source_format != func_table[i].source)
audio/src/src.c:	a = &cd->param;
audio/src/src.c:	fs_in = cd->source_rate;
audio/src/src.c:	fs_out = cd->sink_rate;
audio/src/src.c:	source_frames = cd->source_frames;
audio/src/src.c:	void *sbuf_end_addr = &cd->delay_lines[cd->param.sbuf_length];
audio/src/src.c:	size_t sbuf_size = cd->param.sbuf_length * sizeof(int32_t);
audio/src/src.c:	int sbuf_free = cd->param.sbuf_length - cd->sbuf_avail;
audio/src/src.c:	int sz = cd->sample_container_bytes;
audio/src/src.c:	uint32_t source_frag_size = cd->param.blk_in * source_get_frame_bytes(source);
audio/src/src.c:	uint32_t sink_frag_size = cd->param.blk_out * sink_get_frame_bytes(sink);
audio/src/src.c:	s1.state = &cd->src.state1;
audio/src/src.c:	s1.stage = cd->src.stage1;
audio/src/src.c:	s1.y_wptr = cd->sbuf_w_ptr;
audio/src/src.c:	s1.shift = cd->data_shift;
audio/src/src.c:	s2.state = &cd->src.state2;
audio/src/src.c:	s2.stage = cd->src.stage2;
audio/src/src.c:	s2.x_rptr = cd->sbuf_r_ptr;
audio/src/src.c:	s2.shift = cd->data_shift;
audio/src/src.c:	s1.times = cd->param.stage1_times;
audio/src/src.c:	s1_blk_out = s1.times * cd->src.stage1->blk_out * nch;
audio/src/src.c:		s1.times = sbuf_free / (cd->src.stage1->blk_out * nch);
audio/src/src.c:		s1_blk_out = s1.times * cd->src.stage1->blk_out * nch;
audio/src/src.c:	s1_blk_in = s1.times * cd->src.stage1->blk_in * nch;
audio/src/src.c:		cd->polyphase_func(&s1);
audio/src/src.c:		cd->sbuf_w_ptr = s1.y_wptr;
audio/src/src.c:		cd->sbuf_avail += s1_blk_out;
audio/src/src.c:		n_read += s1.times * cd->src.stage1->blk_in;
audio/src/src.c:	s2.times = cd->param.stage2_times;
audio/src/src.c:	s2_blk_in = s2.times * cd->src.stage2->blk_in * nch;
audio/src/src.c:	if (s2_blk_in > cd->sbuf_avail) {
audio/src/src.c:		s2.times = cd->sbuf_avail / (cd->src.stage2->blk_in * nch);
audio/src/src.c:		s2_blk_in = s2.times * cd->src.stage2->blk_in * nch;
audio/src/src.c:	s2_blk_out = s2.times * cd->src.stage2->blk_out * nch;
audio/src/src.c:	if (cd->sbuf_avail >= s2_blk_in && free_b >= s2_blk_out * sz) {
audio/src/src.c:		cd->polyphase_func(&s2);
audio/src/src.c:		cd->sbuf_r_ptr = s2.x_rptr;
audio/src/src.c:		cd->sbuf_avail -= s2_blk_in;
audio/src/src.c:		n_written += s2.times * cd->src.stage2->blk_out;
audio/src/src.c:	uint32_t source_frag_size = cd->param.blk_in * source_get_frame_bytes(source);
audio/src/src.c:	uint32_t sink_frag_size = cd->param.blk_out * sink_get_frame_bytes(sink);
audio/src/src.c:	s1.times = cd->param.stage1_times;
audio/src/src.c:	s1.state = &cd->src.state1;
audio/src/src.c:	s1.stage = cd->src.stage1;
audio/src/src.c:	s1.shift = cd->data_shift;
audio/src/src.c:	cd->polyphase_func(&s1);
audio/src/src.c:	int frames = cd->param.blk_in;
audio/src/src.c:		ret = src_stream_pcm_sink_rate_check(cd->ipc_config, params);
audio/src/src.c:		ret = src_stream_pcm_source_rate_check(cd->ipc_config, params);
audio/src/src.c:	sp = &cd->param;
audio/src/src.c:	s1 = cd->src.stage1;
audio/src/src.c:	s2 = cd->src.stage2;
audio/src/src.c:		frames_snk = MIN(frames_snk, cd->sink_frames + s2->blk_out);
audio/src/src.c:		frames_src = MIN(frames_src, cd->source_frames + s1->blk_in);
audio/src/src.c:		frames_snk = MIN(frames_snk, cd->sink_frames + s1->blk_out);
audio/src/src.c:		  cd->source_rate, cd->sink_rate);
audio/src/src.c:		 cd->sample_container_bytes, cd->channels_count, dev->frames);
audio/src/src.c:	if (!cd->sink_rate) {
audio/src/src.c:	cd->source_frames = dev->frames * cd->source_rate / cd->sink_rate;
audio/src/src.c:	cd->sink_frames = dev->frames;
audio/src/src.c:	err = src_buffer_lengths(dev, cd, cd->channels_count);
audio/src/src.c:	delay_lines_size = ALIGN_UP(sizeof(int32_t) * cd->param.total, 8);
audio/src/src.c:	rfree(cd->delay_lines);
audio/src/src.c:	cd->delay_lines = rballoc(0, SOF_MEM_CAPS_RAM, delay_lines_size);
audio/src/src.c:	if (!cd->delay_lines) {
audio/src/src.c:		comp_err(dev, "src_params(): failed to alloc cd->delay_lines, delay_lines_size = %zu",
audio/src/src.c:	memset(cd->delay_lines, 0, delay_lines_size);
audio/src/src.c:	buffer_start = cd->delay_lines + ALIGN_UP(cd->param.sbuf_length, 2);
audio/src/src.c:	n = src_polyphase_init(&cd->src, &cd->param, buffer_start);
audio/src/src.c:	cd->sbuf_r_ptr = cd->delay_lines;
audio/src/src.c:	cd->sbuf_w_ptr = cd->delay_lines;
audio/src/src.c:	cd->sbuf_avail = 0;
audio/src/src.c:		cd->src_func = src_copy_sxx;
audio/src/src.c:		cd->src_func = src_1s; /* Simpler 1 stage SRC */
audio/src/src.c:		cd->src_func = src_2s; /* Default 2 stage SRC */
audio/src/src.c:		cd->src_func = src_fallback;
audio/src/src.c:	return cd->src_func(cd, sources[0], sinks[0]);
audio/src/src.c:	cd->src_func = src_fallback;
audio/src/src.c:	src_polyphase_reset(&cd->src);
audio/src/src.c:	rfree(cd->delay_lines);
audio/src/src_ipc3.c:	cd->channels_count = source_get_channels(source);
audio/src/src_ipc3.c:	cd->source_rate = source_get_rate(source);
audio/src/src_ipc3.c:	cd->sink_rate = sink_get_rate(sink);
audio/src/src_ipc3.c:	cd->sample_container_bytes = mod->stream_params->sample_container_bytes;
audio/src/src_ipc3.c:		cd->data_shift = 0;
audio/src/src_ipc3.c:		cd->polyphase_func = src_polyphase_stage_cir_s16;
audio/src/src_ipc3.c:		cd->data_shift = 8;
audio/src/src_ipc3.c:		cd->polyphase_func = src_polyphase_stage_cir;
audio/src/src_ipc3.c:		cd->data_shift = 0;
audio/src/src_ipc3.c:		cd->polyphase_func = src_polyphase_stage_cir;
audio/src/src_ipc3.c:	if (!cfg->init_data || cfg->size != sizeof(cd->ipc_config)) {
audio/src/src_ipc3.c:	memcpy_s(&cd->ipc_config, sizeof(cd->ipc_config), cfg->init_data, sizeof(cd->ipc_config));
audio/src/src_ipc3.c:	cd->delay_lines = NULL;
audio/src/src_ipc3.c:	cd->src_func = src_fallback;
audio/src/src_ipc3.c:	cd->polyphase_func = NULL;
audio/src/src_ipc3.c:	src_polyphase_reset(&cd->src);
audio/src/src_ipc4.c:	src_params.rate = cd->ipc_config.sink_rate;
audio/src/src_ipc4.c:	params->rate = cd->ipc_config.sink_rate;
audio/src/src_ipc4.c:	audio_stream_fmt_conversion(cd->ipc_config.base.audio_fmt.depth,
audio/src/src_ipc4.c:				    cd->ipc_config.base.audio_fmt.valid_bit_depth,
audio/src/src_ipc4.c:				    cd->ipc_config.base.audio_fmt.s_type);
audio/src/src_ipc4.c:	sink_set_channels(sink, cd->ipc_config.base.audio_fmt.channels_count);
audio/src/src_ipc4.c:	sink_set_buffer_fmt(sink, cd->ipc_config.base.audio_fmt.interleaving_style);
audio/src/src_ipc4.c:	sink_set_rate(sink, cd->ipc_config.sink_rate);
audio/src/src_ipc4.c:	switch (cd->ipc_config.base.audio_fmt.depth) {
audio/src/src_ipc4.c:		cd->data_shift = 0;
audio/src/src_ipc4.c:		cd->polyphase_func = src_polyphase_stage_cir_s16;
audio/src/src_ipc4.c:		cd->data_shift = 8;
audio/src/src_ipc4.c:		cd->polyphase_func = src_polyphase_stage_cir;
audio/src/src_ipc4.c:		cd->data_shift = 0;
audio/src/src_ipc4.c:		cd->polyphase_func = src_polyphase_stage_cir;
audio/src/src_ipc4.c:			 cd->ipc_config.base.audio_fmt.depth);
audio/src/src_ipc4.c:	if (!cfg->init_data || cfg->size != sizeof(cd->ipc_config)) {
audio/src/src_ipc4.c:	memcpy_s(&cd->ipc_config, sizeof(cd->ipc_config), cfg->init_data, sizeof(cd->ipc_config));
audio/src/src_ipc4.c:	cd->delay_lines = NULL;
audio/src/src_ipc4.c:	cd->src_func = src_fallback;
audio/src/src_ipc4.c:	cd->polyphase_func = NULL;
audio/src/src_ipc4.c:	src_polyphase_reset(&cd->src);
audio/src/src_ipc4.c:		 cd->ipc_config.base.audio_fmt.channels_count,
audio/src/src_ipc4.c:		 cd->ipc_config.base.audio_fmt.depth);
audio/src/src_ipc4.c:		 cd->ipc_config.base.audio_fmt.sampling_frequency, cd->ipc_config.sink_rate);
audio/src/src_ipc4.c:	cd->source_rate = cd->ipc_config.base.audio_fmt.sampling_frequency;
audio/src/src_ipc4.c:	cd->sink_rate = cd->ipc_config.sink_rate;
audio/src/src_ipc4.c:	cd->channels_count = cd->ipc_config.base.audio_fmt.channels_count;
audio/src/src_ipc4.c:	switch (cd->ipc_config.base.audio_fmt.depth) {
audio/src/src_ipc4.c:		cd->sample_container_bytes = sizeof(int16_t);
audio/src/src_ipc4.c:		cd->sample_container_bytes = sizeof(int32_t);
audio/src/src_ipc4.c:			 cd->ipc_config.base.audio_fmt.depth);
audio/tdfb/tdfb.c:	struct fir_state_32x16 *fir = cd->fir;
audio/tdfb/tdfb.c:	rfree(cd->fir_delay);
audio/tdfb/tdfb.c:	cd->fir_delay = NULL;
audio/tdfb/tdfb.c:	cd->fir_delay_size = 0;
audio/tdfb/tdfb.c:	struct sof_tdfb_config *config = cd->config;
audio/tdfb/tdfb.c:	cd->input_channel_select = coefp;
audio/tdfb/tdfb.c:	cd->output_channel_mix = coefp;
audio/tdfb/tdfb.c:	cd->output_stream_mix = coefp;
audio/tdfb/tdfb.c:	cd->filter_angles = (struct sof_tdfb_angle *)coefp;
audio/tdfb/tdfb.c:	cd->mic_locations = (struct sof_tdfb_mic_location *)
audio/tdfb/tdfb.c:		(&cd->filter_angles[config->num_angles]);
audio/tdfb/tdfb.c:	if ((uint8_t *)&cd->mic_locations[config->num_mic_locations] !=
audio/tdfb/tdfb.c:	target_az = wrap_180(cd->az_value * config->angle_enum_mult + config->angle_enum_offs);
audio/tdfb/tdfb.c:		delta = ABS(target_az - wrap_180(cd->filter_angles[i].azimuth));
audio/tdfb/tdfb.c:	idx = cd->filter_angles[min_delta_idx].filter_index;
audio/tdfb/tdfb.c:	if (cd->beam_on) {
audio/tdfb/tdfb.c:			  target_az, cd->filter_angles[min_delta_idx].azimuth, idx);
audio/tdfb/tdfb.c:		cd->output_channel_mix = output_channel_mix_beam_off;
audio/tdfb/tdfb.c:			  cd->filter_angles[min_delta_idx].azimuth, idx);
audio/tdfb/tdfb.c:		fir_init_coef(&cd->fir[i], coef_data);
audio/tdfb/tdfb.c:		if (cd->input_channel_select[i] > max_ch)
audio/tdfb/tdfb.c:			max_ch = cd->input_channel_select[i];
audio/tdfb/tdfb.c:	int32_t *fir_delay = cd->fir_delay;
audio/tdfb/tdfb.c:	for (i = 0; i < cd->config->num_filters; i++) {
audio/tdfb/tdfb.c:		if (cd->fir[i].length > 0)
audio/tdfb/tdfb.c:			fir_init_delay(&cd->fir[i], &fir_delay);
audio/tdfb/tdfb.c:	if (delay_size > cd->fir_delay_size) {
audio/tdfb/tdfb.c:		cd->fir_delay = rballoc(0, SOF_MEM_CAPS_RAM, delay_size);
audio/tdfb/tdfb.c:		if (!cd->fir_delay) {
audio/tdfb/tdfb.c:		memset(cd->fir_delay, 0, delay_size);
audio/tdfb/tdfb.c:		cd->fir_delay_size = delay_size;
audio/tdfb/tdfb.c:	cd->model_handler = comp_data_blob_handler_new(dev);
audio/tdfb/tdfb.c:	if (!cd->model_handler) {
audio/tdfb/tdfb.c:	ret = comp_init_data_blob(cd->model_handler, bs, cfg->data);
audio/tdfb/tdfb.c:		fir_reset(&cd->fir[i]);
audio/tdfb/tdfb.c:	rfree(cd->ctrl_data);
audio/tdfb/tdfb.c:	ipc_msg_free(cd->msg);
audio/tdfb/tdfb.c:	ipc_msg_free(cd->msg);
audio/tdfb/tdfb.c:	comp_data_blob_handler_free(cd->model_handler);
audio/tdfb/tdfb.c:	rfree(cd->ctrl_data);
audio/tdfb/tdfb.c:	if (comp_is_new_data_blob_available(cd->model_handler)) {
audio/tdfb/tdfb.c:		cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/tdfb/tdfb.c:	if (cd->update) {
audio/tdfb/tdfb.c:		cd->update = false;
audio/tdfb/tdfb.c:	frame_count = MIN(frame_count, cd->max_frames) & ~0x1;
audio/tdfb/tdfb.c:		cd->tdfb_func(cd, input_buffers, output_buffers, frame_count);
audio/tdfb/tdfb.c:		comp_dbg(dev, "tdfb_dint %u %d %d %d", cd->direction.trigger, cd->direction.level,
audio/tdfb/tdfb.c:			 (int32_t)(cd->direction.level_ambient >> 32), cd->direction.az_slow);
audio/tdfb/tdfb.c:		if (cd->direction_updates && cd->direction_change) {
audio/tdfb/tdfb.c:			cd->direction_change = false;
audio/tdfb/tdfb.c:				 cd->az_value_estimate, cd->direction.az_slow);
audio/tdfb/tdfb.c:	cd->config = comp_get_data_blob(cd->model_handler, NULL, NULL);
audio/tdfb/tdfb.c:	if (!cd->config) {
audio/tdfb/tdfb.c:	memset(cd->in, 0, TDFB_IN_BUF_LENGTH * sizeof(int32_t));
audio/tdfb/tdfb.c:	memset(cd->out, 0, TDFB_IN_BUF_LENGTH * sizeof(int32_t));
audio/tdfb/tdfb.c:	cd->max_frames = Q_MULTSR_16X16((int32_t)dev->frames, TDFB_MAX_FRAMES_MULT_Q14, 0, 14, 0);
audio/tdfb/tdfb.c:	comp_dbg(dev, "dev_frames = %d, max_frames = %d", dev->frames, cd->max_frames);
audio/tdfb/tdfb.c:			  cd->direction.max_lag, cd->direction.d_size);
audio/tdfb/tdfb.c:			  (int)cd->direction.line_array, cd->config->angle_enum_mult,
audio/tdfb/tdfb.c:			  cd->config->angle_enum_offs);
audio/tdfb/tdfb.c:	cd->tdfb_func = NULL;
audio/tdfb/tdfb.c:		fir_reset(&cd->fir[i]);
audio/tdfb/tdfb.c:	memset(cd->in, 0, TDFB_IN_BUF_LENGTH * sizeof(int32_t));
audio/tdfb/tdfb.c:	memset(cd->out, 0, TDFB_IN_BUF_LENGTH * sizeof(int32_t));
audio/tdfb/tdfb_comp.h:	cd->tdfb_func = tdfb_fir_s16;
audio/tdfb/tdfb_comp.h:	cd->tdfb_func = tdfb_fir_s24;
audio/tdfb/tdfb_comp.h:	cd->tdfb_func = tdfb_fir_s32;
audio/tdfb/tdfb_direction.c:	if (!cd->direction_updates)
audio/tdfb/tdfb_direction.c:	y = iir_df1(&cd->direction.emphasis[*ch], x);
audio/tdfb/tdfb_direction.c:	*cd->direction.wp = sat_int16(Q_SHIFT_RND(y, 31, 18)); /* 18 dB boost after high-pass */
audio/tdfb/tdfb_direction.c:	cd->direction.wp++;
audio/tdfb/tdfb_direction.c:	tdfb_cinc_s16(&cd->direction.wp, cd->direction.d_end, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:	for (i = 0; i < cd->config->num_mic_locations; i++) {
audio/tdfb/tdfb_direction.c:		for (j = 0; i < cd->config->num_mic_locations; i++) {
audio/tdfb/tdfb_direction.c:			dx = cd->mic_locations[i].x - cd->mic_locations[j].x;
audio/tdfb/tdfb_direction.c:			dy = cd->mic_locations[i].y - cd->mic_locations[j].y;
audio/tdfb/tdfb_direction.c:			dz = cd->mic_locations[i].z - cd->mic_locations[j].z;
audio/tdfb/tdfb_direction.c:	int num_mic_locations = cd->config->num_mic_locations;
audio/tdfb/tdfb_direction.c:		a = cd->mic_locations[i + 1].x - cd->mic_locations[i].x;
audio/tdfb/tdfb_direction.c:		b = cd->mic_locations[i + 1].y - cd->mic_locations[i].y;
audio/tdfb/tdfb_direction.c:		c = cd->mic_locations[i + 1].z - cd->mic_locations[i].z;
audio/tdfb/tdfb_direction.c:		d = cd->mic_locations[i + 2].x - cd->mic_locations[i].x;
audio/tdfb/tdfb_direction.c:		e = cd->mic_locations[i + 2].y - cd->mic_locations[i].y;
audio/tdfb/tdfb_direction.c:		f = cd->mic_locations[i + 2].z - cd->mic_locations[i].z;
audio/tdfb/tdfb_direction.c:	cd->direction.df1_delay = delay;
audio/tdfb/tdfb_direction.c:		iir_init_coef_df1(&cd->direction.emphasis[i], filt);
audio/tdfb/tdfb_direction.c:		iir_init_delay_df1(&cd->direction.emphasis[i], &delay);
audio/tdfb/tdfb_direction.c:	cd->direction.unit_delay = Q_SHIFT_LEFT(1LL, 0, 31) / fs;
audio/tdfb/tdfb_direction.c:	cd->direction.max_lag = Q_MULTSR_32X32((int64_t)fs, t_max, 0, 15, 0) + 1;
audio/tdfb/tdfb_direction.c:	n = (cd->max_frames + (2 * cd->direction.max_lag + 1)) * ch_count;
audio/tdfb/tdfb_direction.c:	cd->direction.d_size =  n * sizeof(int16_t);
audio/tdfb/tdfb_direction.c:	cd->direction.d = rzalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:	if (!cd->direction.d)
audio/tdfb/tdfb_direction.c:	cd->direction.d_end = cd->direction.d + n;
audio/tdfb/tdfb_direction.c:	cd->direction.rp = cd->direction.d;
audio/tdfb/tdfb_direction.c:	cd->direction.wp = cd->direction.d + ch_count * (cd->direction.max_lag + 1);
audio/tdfb/tdfb_direction.c:	cd->direction.r_size = (2 * cd->direction.max_lag + 1) * sizeof(int32_t);
audio/tdfb/tdfb_direction.c:	cd->direction.r = rzalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM, cd->direction.r_size);
audio/tdfb/tdfb_direction.c:	if (!cd->direction.r)
audio/tdfb/tdfb_direction.c:	cd->direction.line_array = line_array_mode_check(cd);
audio/tdfb/tdfb_direction.c:	cd->direction.az = 0;
audio/tdfb/tdfb_direction.c:	cd->direction.step_sign = 1;
audio/tdfb/tdfb_direction.c:	rfree(cd->direction.d);
audio/tdfb/tdfb_direction.c:	cd->direction.d = NULL;
audio/tdfb/tdfb_direction.c:	rfree(cd->direction.df1_delay);
audio/tdfb/tdfb_direction.c:	cd->direction.df1_delay = NULL;
audio/tdfb/tdfb_direction.c:	rfree(cd->direction.df1_delay);
audio/tdfb/tdfb_direction.c:	rfree(cd->direction.d);
audio/tdfb/tdfb_direction.c:	rfree(cd->direction.r);
audio/tdfb/tdfb_direction.c:	int16_t *p = cd->direction.rp + channel;
audio/tdfb/tdfb_direction.c:		tdfb_cinc_s16(&p, cd->direction.d_end, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:	cd->direction.level = sat_int32(tmp / frames);
audio/tdfb/tdfb_direction.c:	level = ((int64_t)cd->direction.level) << 32;
audio/tdfb/tdfb_direction.c:	ambient = cd->direction.level_ambient;
audio/tdfb/tdfb_direction.c:	cd->direction.level_ambient = ambient;
audio/tdfb/tdfb_direction.c:	cd->direction.trigger <<= 1;
audio/tdfb/tdfb_direction.c:	if (cd->direction.level > thr)
audio/tdfb/tdfb_direction.c:		cd->direction.trigger |= 1;
audio/tdfb/tdfb_direction.c:	cd->direction.frame_count_since_control += frames;
audio/tdfb/tdfb_direction.c:	if (cd->direction.frame_count_since_control < 0)
audio/tdfb/tdfb_direction.c:		cd->direction.frame_count_since_control = INT32_MAX;
audio/tdfb/tdfb_direction.c:	int max_lag = cd->direction.max_lag;
audio/tdfb/tdfb_direction.c:			y = cd->direction.rp; /* First channel */
audio/tdfb/tdfb_direction.c:			tdfb_cinc_s16(&x, cd->direction.d_end, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:			tdfb_cdec_s16(&x, cd->direction.d, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:				tdfb_cinc_s16(&y, cd->direction.d_end, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:				tdfb_cinc_s16(&x, cd->direction.d_end, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:			cd->direction.r[k + max_lag] = sat_int32(((r >> 8) + 1) >> 1);
audio/tdfb/tdfb_direction.c:		r_max_idx = find_max_value_index(&cd->direction.r[0], 2 * max_lag + 1);
audio/tdfb/tdfb_direction.c:		cd->direction.timediff[c - 1] = (int32_t)(r_max_idx - max_lag) *
audio/tdfb/tdfb_direction.c:			cd->direction.unit_delay;
audio/tdfb/tdfb_direction.c:	cd->direction.rp += frames * ch_count;
audio/tdfb/tdfb_direction.c:	tdfb_cinc_s16(&cd->direction.rp, cd->direction.d_end, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:	dx = x - cd->mic_locations[mic_n].x;
audio/tdfb/tdfb_direction.c:	dy = y - cd->mic_locations[mic_n].y;
audio/tdfb/tdfb_direction.c:	dz = z - cd->mic_locations[mic_n].z;
audio/tdfb/tdfb_direction.c:	int n_mic = cd->config->num_mic_locations;
audio/tdfb/tdfb_direction.c:		cd->direction.timediff_iter[i] =
audio/tdfb/tdfb_direction.c:	for (i = 0; i < cd->config->num_mic_locations - 1; i++) {
audio/tdfb/tdfb_direction.c:		delta = cd->direction.timediff[i] - cd->direction.timediff_iter[i];
audio/tdfb/tdfb_direction.c:	int az_step = AZ_STEP * cd->direction.step_sign;
audio/tdfb/tdfb_direction.c:	int az = cd->direction.az_slow;
audio/tdfb/tdfb_direction.c:	cd->direction.step_sign *= -1;
audio/tdfb/tdfb_direction.c:	if (cd->direction.line_array) {
audio/tdfb/tdfb_direction.c:	cd->direction.az = az;
audio/tdfb/tdfb_direction.c:	ds1 = cd->direction.az_slow - az;
audio/tdfb/tdfb_direction.c:	ds2 = cd->direction.az_slow - (az - 360);
audio/tdfb/tdfb_direction.c:		ds2 = cd->direction.az_slow - (az + 360);
audio/tdfb/tdfb_direction.c:		Q_MULTSR_16X16((int32_t)cd->direction.az_slow, SLOW_AZ_C2, 12, 15, 12);
audio/tdfb/tdfb_direction.c:	cd->direction.az_slow = unwrap_radians(az_slow);
audio/tdfb/tdfb_direction.c:	cd->direction.rp += frames * ch_count;
audio/tdfb/tdfb_direction.c:	tdfb_cinc_s16(&cd->direction.rp, cd->direction.d_end, cd->direction.d_size);
audio/tdfb/tdfb_direction.c:	deg = Q_MULTS_16X16((int32_t)cd->direction.az_slow, COEF_RAD_TO_DEG, 12, 9, 0) -
audio/tdfb/tdfb_direction.c:		cd->config->angle_enum_offs;
audio/tdfb/tdfb_direction.c:	new_az_value = ((2 * deg / cd->config->angle_enum_mult) + 1) >> 1;
audio/tdfb/tdfb_direction.c:	if (new_az_value * cd->config->angle_enum_mult == 360)
audio/tdfb/tdfb_direction.c:		new_az_value -= 360 / cd->config->angle_enum_mult;
audio/tdfb/tdfb_direction.c:	if (!cd->direction_updates)
audio/tdfb/tdfb_direction.c:	if (!(cd->direction.trigger & 1)) {
audio/tdfb/tdfb_direction.c:	time_since = Q_MULTS_32X32((int64_t)cd->direction.unit_delay,
audio/tdfb/tdfb_direction.c:				   cd->direction.frame_count_since_control, 31, 0, 16);
audio/tdfb/tdfb_direction.c:	if (new_az_value != cd->az_value_estimate && time_since > CONTROL_UPDATE_MIN_TIME &&
audio/tdfb/tdfb_direction.c:	    (cd->direction.trigger & CONTROL_UPDATE_MIN_MASK) == CONTROL_UPDATE_MIN_MASK) {
audio/tdfb/tdfb_direction.c:		cd->az_value_estimate = new_az_value;
audio/tdfb/tdfb_direction.c:		cd->direction.frame_count_since_control = 0;
audio/tdfb/tdfb_direction.c:		cd->direction_change = true;
audio/tdfb/tdfb_generic.c:	const int num_filters = cd->config->num_filters;
audio/tdfb/tdfb_generic.c:	memset(cd->out, 0,  2 * out_nch * sizeof(int32_t));
audio/tdfb/tdfb_generic.c:		is = cd->input_channel_select[i];
audio/tdfb/tdfb_generic.c:		om = cd->output_channel_mix[i];
audio/tdfb/tdfb_generic.c:		filter = &cd->fir[i];
audio/tdfb/tdfb_generic.c:		fir_32x16_2x(filter, cd->in[is], cd->in[is2], &y0, &y1);
audio/tdfb/tdfb_generic.c:				cd->out[k] += y0;
audio/tdfb/tdfb_generic.c:				cd->out[k + out_nch] += y1;
audio/tdfb/tdfb_generic.c:				cd->in[i] = *x << 16;
audio/tdfb/tdfb_generic.c:				*y = sat_int16(Q_SHIFT_RND(cd->out[i], 27, 15));
audio/tdfb/tdfb_generic.c:				cd->in[i] = *x << 8;
audio/tdfb/tdfb_generic.c:				*y = sat_int24(Q_SHIFT_RND(cd->out[i], 27, 23));
audio/tdfb/tdfb_generic.c:			memset(cd->out, 0, 2 * out_nch * sizeof(int32_t));
audio/tdfb/tdfb_generic.c:				cd->in[i] = *x;
audio/tdfb/tdfb_generic.c:				*y = sat_int32((int64_t)cd->out[i] << 4);
audio/tdfb/tdfb_hifi3.c:	struct sof_tdfb_config *cfg = cd->config;
audio/tdfb/tdfb_hifi3.c:			memset(cd->out, 0,  2 * out_nch * sizeof(int32_t));
audio/tdfb/tdfb_hifi3.c:				cd->in[i] = (ae_int32)AE_CVT32X2F16_32(d);
audio/tdfb/tdfb_hifi3.c:				tdfb_direction_copy_emphasis(cd, in_nch, &emp_ch, cd->in[i]);
audio/tdfb/tdfb_hifi3.c:				is = cd->input_channel_select[i];
audio/tdfb/tdfb_hifi3.c:				om = cd->output_channel_mix[i];
audio/tdfb/tdfb_hifi3.c:				f = &cd->fir[i];
audio/tdfb/tdfb_hifi3.c:				fir_32x16_2x_hifi3(f, cd->in[is], cd->in[is2], &y0, &y1,
audio/tdfb/tdfb_hifi3.c:						cd->out[k] += (int32_t)y0 >> 4;
audio/tdfb/tdfb_hifi3.c:						cd->out[k + out_nch] +=
audio/tdfb/tdfb_hifi3.c:				d = AE_ROUND16X4F32SSYM(0, AE_SLAI32S(cd->out[i], 4));
audio/tdfb/tdfb_hifi3.c:	struct sof_tdfb_config *cfg = cd->config;
audio/tdfb/tdfb_hifi3.c:			memset(cd->out, 0,  2 * out_nch * sizeof(int32_t));
audio/tdfb/tdfb_hifi3.c:				cd->in[i] = AE_SLAI32(d, 8);
audio/tdfb/tdfb_hifi3.c:				tdfb_direction_copy_emphasis(cd, in_nch, &emp_ch, cd->in[i]);
audio/tdfb/tdfb_hifi3.c:				is = cd->input_channel_select[i];
audio/tdfb/tdfb_hifi3.c:				om = cd->output_channel_mix[i];
audio/tdfb/tdfb_hifi3.c:				f = &cd->fir[i];
audio/tdfb/tdfb_hifi3.c:				fir_32x16_2x_hifi3(f, cd->in[is], cd->in[is2], &y0, &y1,
audio/tdfb/tdfb_hifi3.c:						cd->out[k] += (int32_t)y0 >> 4;
audio/tdfb/tdfb_hifi3.c:						cd->out[k + out_nch] +=
audio/tdfb/tdfb_hifi3.c:				d = AE_SRAI32(AE_SLAI32S(AE_SRAI32R(cd->out[i], 4), 8), 8);
audio/tdfb/tdfb_hifi3.c:	struct sof_tdfb_config *cfg = cd->config;
audio/tdfb/tdfb_hifi3.c:			memset(cd->out, 0,  2 * out_nch * sizeof(int32_t));
audio/tdfb/tdfb_hifi3.c:				cd->in[i] = d;
audio/tdfb/tdfb_hifi3.c:				tdfb_direction_copy_emphasis(cd, in_nch, &emp_ch, cd->in[i]);
audio/tdfb/tdfb_hifi3.c:				is = cd->input_channel_select[i];
audio/tdfb/tdfb_hifi3.c:				om = cd->output_channel_mix[i];
audio/tdfb/tdfb_hifi3.c:				f = &cd->fir[i];
audio/tdfb/tdfb_hifi3.c:				fir_32x16_2x_hifi3(f, cd->in[is], cd->in[is2], &y0, &y1,
audio/tdfb/tdfb_hifi3.c:						cd->out[k] += (int32_t)y0 >> 4;
audio/tdfb/tdfb_hifi3.c:						cd->out[k + out_nch] +=
audio/tdfb/tdfb_hifi3.c:				d = AE_SLAI32S(cd->out[i], 4);
audio/tdfb/tdfb_hifiep.c:	const int num_filters = cd->config->num_filters;
audio/tdfb/tdfb_hifiep.c:	memset(cd->out, 0, 2 * out_nch * sizeof(int32_t));
audio/tdfb/tdfb_hifiep.c:		is = cd->input_channel_select[i];
audio/tdfb/tdfb_hifiep.c:		om = cd->output_channel_mix[i];
audio/tdfb/tdfb_hifiep.c:		f = &cd->fir[i];
audio/tdfb/tdfb_hifiep.c:		fir_32x16_2x_hifiep(f, cd->in[is], cd->in[is2], &y0, &y1, lshift, rshift);
audio/tdfb/tdfb_hifiep.c:				cd->out[k] += y0 >> 4;
audio/tdfb/tdfb_hifiep.c:				cd->out[k + out_nch] += y1 >> 4;
audio/tdfb/tdfb_hifiep.c:				cd->in[i] = *x << 16;
audio/tdfb/tdfb_hifiep.c:				*y = sat_int16(Q_SHIFT_RND(cd->out[i], 27, 15));
audio/tdfb/tdfb_hifiep.c:				cd->in[i] = *x << 8;
audio/tdfb/tdfb_hifiep.c:				*y = sat_int24(Q_SHIFT_RND(cd->out[i], 27, 23));
audio/tdfb/tdfb_hifiep.c:			memset(cd->out, 0, 2 * out_nch * sizeof(int32_t));
audio/tdfb/tdfb_hifiep.c:				cd->in[i] = *x;
audio/tdfb/tdfb_hifiep.c:				*y = sat_int32((int64_t)cd->out[i] << 4);
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data = rzalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM, TDFB_GET_CTRL_DATA_SIZE);
audio/tdfb/tdfb_ipc3.c:	if (!cd->ctrl_data)
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->rhdr.hdr.cmd = SOF_IPC_GLB_COMP_MSG | SOF_IPC_COMP_GET_VALUE | comp_id;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->rhdr.hdr.size = TDFB_GET_CTRL_DATA_SIZE;
audio/tdfb/tdfb_ipc3.c:	cd->msg = ipc_msg_init(cd->ctrl_data->rhdr.hdr.cmd, cd->ctrl_data->rhdr.hdr.size);
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->comp_id = comp_id;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->type = SOF_CTRL_TYPE_VALUE_CHAN_GET;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->cmd = SOF_CTRL_CMD_ENUM;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->index = SOF_TDFB_CTRL_INDEX_AZIMUTH_ESTIMATE;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->num_elems = 0;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->chanv[0].channel = 0;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->chanv[0].value = cd->az_value_estimate;
audio/tdfb/tdfb_ipc3.c:	cd->ctrl_data->num_elems = 1;
audio/tdfb/tdfb_ipc3.c:	ipc_msg_send(cd->msg, cd->ctrl_data, false);
audio/tdfb/tdfb_ipc3.c:		cdata->chanv[j].value = cd->beam_on;
audio/tdfb/tdfb_ipc3.c:			cdata->chanv[j].value = cd->az_value;
audio/tdfb/tdfb_ipc3.c:			cdata->chanv[j].value = cd->az_value_estimate;
audio/tdfb/tdfb_ipc3.c:	return comp_data_blob_get_cmd(cd->model_handler, cdata, fragment_size);
audio/tdfb/tdfb_ipc3.c:		cd->az_value = cdata->chanv[0].value;
audio/tdfb/tdfb_ipc3.c:		cd->update = true;
audio/tdfb/tdfb_ipc3.c:		cd->az_value_estimate = cdata->chanv[0].value;
audio/tdfb/tdfb_ipc3.c:		cd->beam_on = cdata->chanv[0].value;
audio/tdfb/tdfb_ipc3.c:		cd->update = true;
audio/tdfb/tdfb_ipc3.c:		cd->direction_updates = cdata->chanv[0].value;
audio/tdfb/tdfb_ipc3.c:		ret = comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/tdfb/tdfb_ipc4.c:	cd->msg = tdfb_notification_init(mod, SOF_IPC4_ENUM_CONTROL_PARAM_ID,
audio/tdfb/tdfb_ipc4.c:	if (!cd->msg) {
audio/tdfb/tdfb_ipc4.c:	tdfb_send_notification(cd->msg, cd->az_value_estimate);
audio/tdfb/tdfb_ipc4.c:		cd->az_value = ctl->chanv[0].value;
audio/tdfb/tdfb_ipc4.c:		cd->update = true;
audio/tdfb/tdfb_ipc4.c:		cd->az_value_estimate = ctl->chanv[0].value;
audio/tdfb/tdfb_ipc4.c:		cd->beam_on = ctl->chanv[0].value;
audio/tdfb/tdfb_ipc4.c:		cd->update = true;
audio/tdfb/tdfb_ipc4.c:		cd->direction_updates = ctl->chanv[0].value;
audio/tdfb/tdfb_ipc4.c:		return comp_data_blob_set(cd->model_handler, pos, data_offset_size,
audio/tone.c:	int nch = cd->channels;
audio/tone.c:				tonegen_control(&cd->sg[i]);
audio/tone.c:				*dest = tonegen(&cd->sg[i]);
audio/tone.c:	cd->tone_func = tone_s32_default;
audio/tone.c:	cd->rate = ipc_tone->sample_rate;
audio/tone.c:		tonegen_reset(&cd->sg[i]);
audio/tone.c:	cd->period_bytes = dev->frames *
audio/tone.c:			cdata->chanv[j].value = !cd->sg[j].mute;
audio/tone.c:			comp_info(dev, "tone_cmd_get_value(), j = %u, cd->sg[j].mute = %u",
audio/tone.c:				  j, cd->sg[j].mute);
audio/tone.c:				tonegen_unmute(&cd->sg[ch]);
audio/tone.c:				tonegen_mute(&cd->sg[ch]);
audio/tone.c:				tonegen_update_f(&cd->sg[ch], val);
audio/tone.c:				tonegen_set_a(&cd->sg[ch], val);
audio/tone.c:				tonegen_set_freq_mult(&cd->sg[ch], val);
audio/tone.c:				tonegen_set_ampl_mult(&cd->sg[ch], val);
audio/tone.c:				tonegen_set_length(&cd->sg[ch], val);
audio/tone.c:				tonegen_set_period(&cd->sg[ch], val);
audio/tone.c:				tonegen_set_repeats(&cd->sg[ch], val);
audio/tone.c:				tonegen_set_linramp(&cd->sg[ch], val);
audio/tone.c:	if (free >= cd->period_bytes) {
audio/tone.c:		cd->tone_func(dev, &sink->stream, dev->frames);
audio/tone.c:		buffer_stream_writeback(sink, cd->period_bytes);
audio/tone.c:		comp_update_buffer_produce(sink, cd->period_bytes);
audio/tone.c:	cd->channels = audio_stream_get_channels(&sourceb->stream);
audio/tone.c:	comp_info(dev, "tone_prepare(), cd->channels = %u, cd->rate = %u",
audio/tone.c:		  cd->channels, cd->rate);
audio/tone.c:	for (i = 0; i < cd->channels; i++) {
audio/tone.c:		f = tonegen_get_f(&cd->sg[i]);
audio/tone.c:		a = tonegen_get_a(&cd->sg[i]);
audio/tone.c:		if (tonegen_init(&cd->sg[i], cd->rate, f, a) < 0) {
audio/tone.c:		tonegen_reset(&cd->sg[i]);
audio/up_down_mixer/up_down_mixer.c:	if (cd->downmix_coefficients) {
audio/up_down_mixer/up_down_mixer.c:		cd->downmix_coefficients = custom_coeffs;
audio/up_down_mixer/up_down_mixer.c:		cd->downmix_coefficients = k_lo_ro_downmix32bit;
audio/up_down_mixer/up_down_mixer.c:			cd->downmix_coefficients = k_half_scaled_lo_ro_downmix16bit;
audio/up_down_mixer/up_down_mixer.c:			cd->downmix_coefficients = k_half_scaled_lo_ro_downmix32bit;
audio/up_down_mixer/up_down_mixer.c:			cd->downmix_coefficients = (format->depth == IPC4_DEPTH_16BIT) ?
audio/up_down_mixer/up_down_mixer.c:			cd->downmix_coefficients = (format->depth == IPC4_DEPTH_16BIT) ?
audio/up_down_mixer/up_down_mixer.c:			cd->downmix_coefficients = k_scaled_lo_ro_downmix16bit;
audio/up_down_mixer/up_down_mixer.c:				cd->downmix_coefficients = k_lo_ro_downmix32bit;
audio/up_down_mixer/up_down_mixer.c:				cd->downmix_coefficients = k_scaled_lo_ro_downmix32bit;
audio/up_down_mixer/up_down_mixer.c:		cd->downmix_coefficients = k_scaled_lo_ro_downmix32bit;
audio/up_down_mixer/up_down_mixer.c:		cd->mix_routine = select_mix_out_mono(dev, format);
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].channels_count = 1;
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].ch_cfg = IPC4_CHANNEL_CONFIG_MONO;
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].ch_map = create_channel_map(IPC4_CHANNEL_CONFIG_MONO);
audio/up_down_mixer/up_down_mixer.c:		cd->mix_routine = select_mix_out_stereo(dev, format);
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].channels_count = 2;
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].ch_cfg = IPC4_CHANNEL_CONFIG_STEREO;
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].ch_map = create_channel_map(IPC4_CHANNEL_CONFIG_STEREO);
audio/up_down_mixer/up_down_mixer.c:		cd->mix_routine = select_mix_out_5_1(dev, format);
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].channels_count = 6;
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].ch_cfg = IPC4_CHANNEL_CONFIG_5_POINT_1;
audio/up_down_mixer/up_down_mixer.c:		cd->out_fmt[0].ch_map = create_channel_map(IPC4_CHANNEL_CONFIG_5_POINT_1);
audio/up_down_mixer/up_down_mixer.c:		cd->mix_routine = upmix32bit_2_0_to_7_1;
audio/up_down_mixer/up_down_mixer.c:	cd->out_fmt[0].valid_bit_depth = IPC4_DEPTH_24BIT;
audio/up_down_mixer/up_down_mixer.c:	cd->out_fmt[0].depth = IPC4_DEPTH_32BIT;
audio/up_down_mixer/up_down_mixer.c:	cd->in_channel_no = format->channels_count;
audio/up_down_mixer/up_down_mixer.c:	cd->in_channel_map = format->ch_map;
audio/up_down_mixer/up_down_mixer.c:	cd->in_channel_config = format->ch_cfg;
audio/up_down_mixer/up_down_mixer.c:	rfree(cd->buf_in);
audio/up_down_mixer/up_down_mixer.c:	rfree(cd->buf_out);
audio/up_down_mixer/up_down_mixer.c:	cd->buf_in = rballoc(0, SOF_MEM_CAPS_RAM, mod->priv.cfg.base_cfg.ibs);
audio/up_down_mixer/up_down_mixer.c:	cd->buf_out = rballoc(0, SOF_MEM_CAPS_RAM, mod->priv.cfg.base_cfg.obs);
audio/up_down_mixer/up_down_mixer.c:	if (!cd->buf_in || !cd->buf_out) {
audio/up_down_mixer/up_down_mixer.c:		cd->out_channel_map = create_channel_map(up_down_mixer->out_channel_config);
audio/up_down_mixer/up_down_mixer.c:		cd->out_channel_map = create_channel_map(up_down_mixer->out_channel_config);
audio/up_down_mixer/up_down_mixer.c:		cd->out_channel_map = up_down_mixer->channel_map;
audio/up_down_mixer/up_down_mixer.c:		cd->out_channel_map = up_down_mixer->channel_map;
audio/up_down_mixer/up_down_mixer.c:	cd->mix_routine(cd, (const void *)input0_start, input_cirbuf_size, (void *)output_start);
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LFE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LFE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool left = (get_channel_location(cd->in_channel_map, CHANNEL_LEFT) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool center = (get_channel_location(cd->in_channel_map, CHANNEL_CENTER) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool right = (get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool lfe = (get_channel_location(cd->in_channel_map, CHANNEL_LFE) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_LFE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint32_t number_of_samples_in_one_channel = in_size / cd->in_channel_no;
audio/up_down_mixer/up_down_mixer_hifi3.c:	int sample_offset = cd->in_channel_no << 2;
audio/up_down_mixer/up_down_mixer_hifi3.c:			if (cd->in_channel_config == IPC4_CHANNEL_CONFIG_4_POINT_0) {
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:	const uint8_t left_slot =     get_channel_location(cd->in_channel_map, CHANNEL_LEFT);
audio/up_down_mixer/up_down_mixer_hifi3.c:	const uint8_t center_slot =   get_channel_location(cd->in_channel_map, CHANNEL_CENTER);
audio/up_down_mixer/up_down_mixer_hifi3.c:	const uint8_t right_slot =    get_channel_location(cd->in_channel_map, CHANNEL_RIGHT);
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint8_t left_surround_slot =  get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND);
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint8_t right_surround_slot = get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND);
audio/up_down_mixer/up_down_mixer_hifi3.c:	const uint8_t lfe_slot =      get_channel_location(cd->in_channel_map, CHANNEL_LFE);
audio/up_down_mixer/up_down_mixer_hifi3.c:		left_surround_slot = get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SIDE);
audio/up_down_mixer/up_down_mixer_hifi3.c:		right_surround_slot = get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SIDE);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		P_coefficient_left_surround  = AE_L32_X((ae_int32 *)cd->downmix_coefficients,
audio/up_down_mixer/up_down_mixer_hifi3.c:		P_coefficient_right_surround = AE_L32_X((ae_int32 *)cd->downmix_coefficients,
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SIDE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SIDE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LFE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SIDE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SIDE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool left = (get_channel_location(cd->in_channel_map, CHANNEL_LEFT) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool center = (get_channel_location(cd->in_channel_map, CHANNEL_CENTER) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool right = (get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:	bool lfe = (get_channel_location(cd->in_channel_map, CHANNEL_LFE) != 0xF);
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:			(get_channel_location(cd->in_channel_map, CHANNEL_LFE) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint32_t number_of_samples_in_one_channel = in_size / cd->in_channel_no;
audio/up_down_mixer/up_down_mixer_hifi3.c:	int sample_offset = cd->in_channel_no << 1;
audio/up_down_mixer/up_down_mixer_hifi3.c:			if (cd->in_channel_config == IPC4_CHANNEL_CONFIG_4_POINT_0) {
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LFE) << 1));
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint32_t number_of_samples_in_one_channel = in_size / cd->in_channel_no;
audio/up_down_mixer/up_down_mixer_hifi3.c:	int sample_offset = cd->in_channel_no << 1;
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint32_t idx1 = get_channel_index(cd->in_channel_map, 0);
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint32_t idx2 = get_channel_index(cd->in_channel_map, 1);
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint32_t idx3 = get_channel_index(cd->in_channel_map, 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint32_t idx4 = get_channel_index(cd->in_channel_map, 3);
audio/up_down_mixer/up_down_mixer_hifi3.c:	uint16_t coeffs[4] = {cd->downmix_coefficients[idx1],
audio/up_down_mixer/up_down_mixer_hifi3.c:			      cd->downmix_coefficients[idx2],
audio/up_down_mixer/up_down_mixer_hifi3.c:			      cd->downmix_coefficients[idx3],
audio/up_down_mixer/up_down_mixer_hifi3.c:			      cd->downmix_coefficients[idx4]
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LFE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SIDE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SIDE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SIDE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SIDE) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_CENTER << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SURROUND << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LFE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_LEFT_SIDE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		AE_L32_X((ae_int32 *)cd->downmix_coefficients, CHANNEL_RIGHT_SIDE << 2);
audio/up_down_mixer/up_down_mixer_hifi3.c:		(get_channel_location(cd->in_channel_map, CHANNEL_CENTER_SURROUND) << 2));
audio/up_down_mixer/up_down_mixer_hifi3.c:	channel_map out_channel_map = cd->out_channel_map;
audio/up_down_mixer/up_down_mixer_hifi3.c:		left_surround_slot = get_channel_location(cd->in_channel_map, CHANNEL_LEFT_SIDE);
audio/up_down_mixer/up_down_mixer_hifi3.c:		right_surround_slot = get_channel_location(cd->in_channel_map, CHANNEL_RIGHT_SIDE);
audio/volume/volume.c:	if (!cd->initial_ramp)
audio/volume/volume.c:		return cd->tvolume[channel];
audio/volume/volume.c:	return cd->rvolume[channel] + ramp_time * cd->ramp_coef[channel];
audio/volume/volume.c:	int32_t volume_delta = cd->tvolume[channel] - cd->rvolume[channel]; /* Q16.16 */
audio/volume/volume.c:	if (!cd->initial_ramp)
audio/volume/volume.c:		return cd->tvolume[channel];
audio/volume/volume.c:	time_ratio = (((int64_t)ramp_time) << 30) / (cd->initial_ramp << 3);
audio/volume/volume.c:	return cd->rvolume[channel] + Q_MULTSR_32X32((int64_t)volume_delta, pow_value, 16, 30, 16);
audio/volume/volume.c:		if (cd->tvolume[0] != cd->tvolume[i] || cd->volume[0] != cd->volume[i]) {
audio/volume/volume.c:		cd->ramp_channel_counter = 1;
audio/volume/volume.c:		cd->ramp_channel_counter = channels_count;
audio/volume/volume.c:	cd->ramp_channel_counter = 2;
audio/volume/volume.c:		is_same_volume, cd->ramp_channel_counter);
audio/volume/volume.c:	cd->ramp_finished = true;
audio/volume/volume.c:	cd->copy_gain = true;
audio/volume/volume.c:	int32_t ramp_time = Q_MULTSR_32X32((int64_t)cd->vol_ramp_elapsed_frames,
audio/volume/volume.c:					   cd->sample_rate_inv, 0, 31, 3);
audio/volume/volume.c:	for (i = 0; i < cd->ramp_channel_counter; i++) {
audio/volume/volume.c:		volume = cd->volume[i];
audio/volume/volume.c:		tvolume = cd->tvolume[i];
audio/volume/volume.c:		switch (cd->ramp_type) {
audio/volume/volume.c:				cd->ramp_finished = false;
audio/volume/volume.c:				cd->ramp_finished = false;
audio/volume/volume.c:		cd->volume[i] = new_vol;
audio/volume/volume.c:	for (i = cd->ramp_channel_counter; i < cd->channels; i++)
audio/volume/volume.c:		cd->volume[i] = cd->volume[0];
audio/volume/volume.c:	cd->is_passthrough = cd->ramp_finished;
audio/volume/volume.c:	for (i = 0; i < cd->channels; i++) {
audio/volume/volume.c:		if (cd->volume[i] != VOL_ZERO_DB) {
audio/volume/volume.c:			cd->is_passthrough = false;
audio/volume/volume.c:		cd->rvolume[i] = 0;
audio/volume/volume.c:		cd->ramp_coef[i] = 0;
audio/volume/volume.c:	cd->channels = 0;
audio/volume/volume.c:	cd->ramp_finished = true;
audio/volume/volume.c:	cd->vol_ramp_frames = 0;
audio/volume/volume.c:	cd->vol_ramp_elapsed_frames = 0;
audio/volume/volume.c:	cd->sample_rate_inv = 0;
audio/volume/volume.c:	cd->copy_gain = true;
audio/volume/volume.c:	cd->is_passthrough = false;
audio/volume/volume.c:	if (cd->initial_ramp < VOL_RAMP_UPDATE_THRESHOLD_FASTEST_MS)
audio/volume/volume.c:	else if (cd->initial_ramp < VOL_RAMP_UPDATE_THRESHOLD_FAST_MS)
audio/volume/volume.c:	else if (cd->initial_ramp < VOL_RAMP_UPDATE_THRESHOLD_SLOW_MS)
audio/volume/volume.c:		cd->vol_ramp_frames = dev->frames;
audio/volume/volume.c:		cd->vol_ramp_frames = dev->frames / (dev->period / ramp_update_us);
audio/volume/volume.c:	rfree(cd->vol);
audio/volume/volume.c:	if (!cd->initial_ramp)
audio/volume/volume.c:	delta = cd->tvolume[chan] - cd->volume[chan];
audio/volume/volume.c:		cd->ramp_coef[chan] = 0;
audio/volume/volume.c:	if (constant_rate_ramp && cd->vol_ramp_range > 0)
audio/volume/volume.c:		coef = cd->vol_ramp_range;
audio/volume/volume.c:	coef = (2 * coef / cd->initial_ramp + 1) >> 1;
audio/volume/volume.c:	cd->ramp_coef[chan] = coef;
audio/volume/volume.c:	if (v < cd->vol_min) {
audio/volume/volume.c:			  v, cd->vol_min);
audio/volume/volume.c:		v = cd->vol_min;
audio/volume/volume.c:	if (v > cd->vol_max) {
audio/volume/volume.c:			  v, cd->vol_max);
audio/volume/volume.c:		v = cd->vol_max;
audio/volume/volume.c:	cd->tvolume[chan] = v;
audio/volume/volume.c:	cd->rvolume[chan] = cd->volume[chan];
audio/volume/volume.c:	cd->vol_ramp_elapsed_frames = 0;
audio/volume/volume.c:	if (cd->ramp_type == SOF_VOLUME_LINEAR || cd->ramp_type == SOF_VOLUME_LINEAR_ZC)
audio/volume/volume.c:	if (!cd->initial_ramp || cd->ramp_type == SOF_VOLUME_WINDOWS_NO_FADE)
audio/volume/volume.c:		cd->volume[chan] = v;
audio/volume/volume.c:	if (!cd->muted[chan]) {
audio/volume/volume.c:		cd->mvolume[chan] = cd->tvolume[chan];
audio/volume/volume.c:		cd->muted[chan] = true;
audio/volume/volume.c:	if (cd->muted[chan]) {
audio/volume/volume.c:		cd->muted[chan] = false;
audio/volume/volume.c:		volume_set_chan(mod, chan, cd->mvolume[chan], true);
audio/volume/volume.c:		if (cd->ramp_finished || cd->vol_ramp_frames > avail_frames) {
audio/volume/volume.c:		} else if (cd->ramp_type == SOF_VOLUME_LINEAR_ZC) {
audio/volume/volume.c:			frames = cd->zc_get(input_buffers[0].data, cd->vol_ramp_frames, &prev_sum);
audio/volume/volume.c:			frames = cd->vol_ramp_frames;
audio/volume/volume.c:		if (!cd->ramp_finished) {
audio/volume/volume.c:			cd->vol_ramp_elapsed_frames += frames;
audio/volume/volume.c:		cd->scale_vol(mod, &input_buffers[0], &output_buffers[0], frames, cd->attenuation);
audio/volume/volume.c:	cd->peak_cnt++;
audio/volume/volume.c:	if (cd->peak_cnt == cd->peak_report_cnt) {
audio/volume/volume.c:		cd->peak_cnt = 0;
audio/volume/volume.c:		memset(cd->peak_regs.peak_meter, 0, sizeof(cd->peak_regs.peak_meter));
audio/volume/volume.c:		memset(cd->peak_vol, 0, sizeof(int32_t) * SOF_IPC_MAX_CHANNELS * 4);
audio/volume/volume.c:	if (!cd->scale_vol) {
audio/volume/volume.c:		comp_err(dev, "volume_prepare(): invalid cd->scale_vol");
audio/volume/volume.c:	cd->zc_get = vol_get_zc_function(dev, sinkb);
audio/volume/volume.c:	if (!cd->zc_get) {
audio/volume/volume.c:		comp_err(dev, "volume_prepare(): invalid cd->zc_get");
audio/volume/volume.c:	cd->ramp_finished = false;
audio/volume/volume.c:	cd->channels = audio_stream_get_channels(&sinkb->stream);
audio/volume/volume.c:	comp_info(dev, "volume_prepare(): channels %d period %d", cd->channels,  sink_period_bytes);
audio/volume/volume.c:	if (cd->channels > SOF_IPC_MAX_CHANNELS) {
audio/volume/volume.c:	cd->sample_rate_inv = (int32_t)(1000LL * INT32_MAX /
audio/volume/volume.c:	for (i = 0; i < cd->channels; i++) {
audio/volume/volume.c:		cd->volume[i] = cd->vol_min;
audio/volume/volume.c:		volume_set_chan(mod, i, cd->tvolume[i], false);
audio/volume/volume.c:		if (cd->volume[i] != cd->tvolume[i])
audio/volume/volume.c:			cd->ramp_finished = false;
audio/volume/volume.h:		if (cd->is_passthrough)
audio/volume/volume.h:	if (cd->is_passthrough) {
audio/volume/volume.h:	mailbox_sw_regs_write(cd->mailbox_offset, &cd->peak_regs, sizeof(cd->peak_regs));
audio/volume/volume_generic.c:			vol = cd->volume[j];
audio/volume/volume_generic.c:			vol = cd->volume[j];
audio/volume/volume_generic.c:			vol = cd->volume[j];
audio/volume/volume_generic_with_peakvol.c:			vol = cd->volume[j];
audio/volume/volume_generic_with_peakvol.c:			cd->peak_regs.peak_meter[j] = MAX(tmp, cd->peak_regs.peak_meter[j]);
audio/volume/volume_generic_with_peakvol.c:			cd->peak_regs.peak_meter[j] = MAX(tmp, cd->peak_regs.peak_meter[j]);
audio/volume/volume_generic_with_peakvol.c:			vol = cd->volume[j];
audio/volume/volume_generic_with_peakvol.c:			cd->peak_regs.peak_meter[j] = MAX(tmp, cd->peak_regs.peak_meter[j]);
audio/volume/volume_generic_with_peakvol.c:			cd->peak_regs.peak_meter[j] = MAX(tmp, cd->peak_regs.peak_meter[j]);
audio/volume/volume_generic_with_peakvol.c:			vol = cd->volume[j];
audio/volume/volume_generic_with_peakvol.c:			cd->peak_regs.peak_meter[j] = MAX(tmp, cd->peak_regs.peak_meter[j]);
audio/volume/volume_generic_with_peakvol.c:			cd->peak_regs.peak_meter[j] = MAX(tmp, cd->peak_regs.peak_meter[j]);
audio/volume/volume_hifi3.c:		cd->vol[i] = cd->volume[i];
audio/volume/volume_hifi3.c:		cd->vol[i + channels_count * 1] = cd->volume[i];
audio/volume/volume_hifi3.c:		cd->vol[i + channels_count * 2] = cd->volume[i];
audio/volume/volume_hifi3.c:		cd->vol[i + channels_count * 3] = cd->volume[i];
audio/volume/volume_hifi3.c:	cd->copy_gain = false;
audio/volume/volume_hifi3.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi3.c:	if (cd->copy_gain)
audio/volume/volume_hifi3.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi3.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 2);
audio/volume/volume_hifi3.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi3.c:	if (cd->copy_gain)
audio/volume/volume_hifi3.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi3.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 2);
audio/volume/volume_hifi3.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi3.c:	if (cd->copy_gain)
audio/volume/volume_hifi3.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi3.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 4);
audio/volume/volume_hifi3_with_peakvol.c:	uint32_t *peak_meter = cd->peak_regs.peak_meter;
audio/volume/volume_hifi3_with_peakvol.c:			volume = (ae_f32x2)cd->volume[channel];
audio/volume/volume_hifi3_with_peakvol.c:	uint32_t *peak_meter = cd->peak_regs.peak_meter;
audio/volume/volume_hifi3_with_peakvol.c:	uint32_t *peak_meter = cd->peak_regs.peak_meter;
audio/volume/volume_hifi3_with_peakvol.c:			volume = (ae_f32x2)cd->volume[channel];
audio/volume/volume_hifi3_with_peakvol.c:	uint32_t *peak_meter = cd->peak_regs.peak_meter;
audio/volume/volume_hifi3_with_peakvol.c:	uint32_t *peak_meter = cd->peak_regs.peak_meter;
audio/volume/volume_hifi3_with_peakvol.c:			volume = (ae_f32x2)cd->volume[channel];
audio/volume/volume_hifi3_with_peakvol.c:	uint32_t *peak_meter = cd->peak_regs.peak_meter;
audio/volume/volume_hifi4.c:		cd->vol[i] = cd->volume[i];
audio/volume/volume_hifi4.c:		cd->vol[i + channels_count * 1] = cd->volume[i];
audio/volume/volume_hifi4.c:		cd->vol[i + channels_count * 2] = cd->volume[i];
audio/volume/volume_hifi4.c:		cd->vol[i + channels_count * 3] = cd->volume[i];
audio/volume/volume_hifi4.c:	cd->copy_gain = false;
audio/volume/volume_hifi4.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi4.c:	if (cd->copy_gain)
audio/volume/volume_hifi4.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi4.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 2);
audio/volume/volume_hifi4.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi4.c:	if (cd->copy_gain)
audio/volume/volume_hifi4.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi4.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 2);
audio/volume/volume_hifi4.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi4.c:	if (cd->copy_gain)
audio/volume/volume_hifi4.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi4.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 4);
audio/volume/volume_hifi4_with_peakvol.c:		cd->vol[i] = cd->volume[i];
audio/volume/volume_hifi4_with_peakvol.c:		cd->vol[i + channels_count * 1] = cd->volume[i];
audio/volume/volume_hifi4_with_peakvol.c:		cd->vol[i + channels_count * 2] = cd->volume[i];
audio/volume/volume_hifi4_with_peakvol.c:		cd->vol[i + channels_count * 3] = cd->volume[i];
audio/volume/volume_hifi4_with_peakvol.c:	cd->copy_gain = false;
audio/volume/volume_hifi4_with_peakvol.c:	ae_f32x2 *peakvol = (ae_f32x2 *)cd->peak_vol;
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCBEGIN1(cd->peak_vol);
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCEND1(cd->peak_vol  + channels_count * 2);
audio/volume/volume_hifi4_with_peakvol.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi4_with_peakvol.c:	if (cd->copy_gain)
audio/volume/volume_hifi4_with_peakvol.c:	vol = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCEND0(cd->vol + channels_count * 2);
audio/volume/volume_hifi4_with_peakvol.c:		cd->peak_regs.peak_meter[i] = MAX(cd->peak_vol[i],
audio/volume/volume_hifi4_with_peakvol.c:						  cd->peak_vol[i + channels_count])
audio/volume/volume_hifi4_with_peakvol.c:	ae_f32x2 *peakvol = (ae_f32x2 *)cd->peak_vol;
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCBEGIN1(cd->peak_vol);
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCEND1(cd->peak_vol  + channels_count * 2);
audio/volume/volume_hifi4_with_peakvol.c:		cd->peak_regs.peak_meter[i] = MAX(cd->peak_vol[i],
audio/volume/volume_hifi4_with_peakvol.c:						  cd->peak_vol[i + channels_count])
audio/volume/volume_hifi4_with_peakvol.c:	ae_f32x2 *peakvol = (ae_f32x2 *)cd->peak_vol;
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCBEGIN1(cd->peak_vol);
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCEND1(cd->peak_vol  + channels_count * 2);
audio/volume/volume_hifi4_with_peakvol.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi4_with_peakvol.c:	if (cd->copy_gain)
audio/volume/volume_hifi4_with_peakvol.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi4_with_peakvol.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 2);
audio/volume/volume_hifi4_with_peakvol.c:		cd->peak_regs.peak_meter[i] = MAX(cd->peak_vol[i],
audio/volume/volume_hifi4_with_peakvol.c:						  cd->peak_vol[i + channels_count]) << attenuation;
audio/volume/volume_hifi4_with_peakvol.c:	ae_f32x2 *peakvol = (ae_f32x2 *)cd->peak_vol;
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCBEGIN1(cd->peak_vol);
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCEND1(cd->peak_vol  + channels_count * 2);
audio/volume/volume_hifi4_with_peakvol.c:		cd->peak_regs.peak_meter[i] = MAX(cd->peak_vol[i],
audio/volume/volume_hifi4_with_peakvol.c:						  cd->peak_vol[i + channels_count]) << attenuation;
audio/volume/volume_hifi4_with_peakvol.c:	ae_f32x2 *peakvol = (ae_f32x2 *)cd->peak_vol;
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCBEGIN1(cd->peak_vol);
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCEND1(cd->peak_vol  + channels_count * 4);
audio/volume/volume_hifi4_with_peakvol.c:	 * error loading of volume gain while the cd->vol would be set
audio/volume/volume_hifi4_with_peakvol.c:	if (cd->copy_gain)
audio/volume/volume_hifi4_with_peakvol.c:	buf = (ae_f32x2 *)cd->vol;
audio/volume/volume_hifi4_with_peakvol.c:	buf_end = (ae_f32x2 *)(cd->vol + channels_count * 4);
audio/volume/volume_hifi4_with_peakvol.c:		m = MAX(cd->peak_vol[i], cd->peak_vol[i + channels_count]);
audio/volume/volume_hifi4_with_peakvol.c:		m = MAX(m, cd->peak_vol[i + channels_count * 2]);
audio/volume/volume_hifi4_with_peakvol.c:		m = MAX(m, cd->peak_vol[i + channels_count * 3]);
audio/volume/volume_hifi4_with_peakvol.c:		cd->peak_regs.peak_meter[i] = m << PEAK_16S_32C_ADJUST;
audio/volume/volume_hifi4_with_peakvol.c:	ae_f32x2 *peakvol = (ae_f32x2 *)cd->peak_vol;
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCBEGIN1(cd->peak_vol);
audio/volume/volume_hifi4_with_peakvol.c:	AE_SETCEND1(cd->peak_vol  + channels_count * 4);
audio/volume/volume_hifi4_with_peakvol.c:		m = MAX(cd->peak_vol[i], cd->peak_vol[i + channels_count]);
audio/volume/volume_hifi4_with_peakvol.c:		m = MAX(m, cd->peak_vol[i + channels_count * 2]);
audio/volume/volume_hifi4_with_peakvol.c:		m = MAX(m, cd->peak_vol[i + channels_count * 3]);
audio/volume/volume_hifi4_with_peakvol.c:		cd->peak_regs.peak_meter[i] = m << PEAK_16S_32C_ADJUST;
audio/volume/volume_ipc3.c:	cd->scale_vol = vol_get_processing_function(dev, bufferb, cd);
audio/volume/volume_ipc3.c:	cd->ramp_finished = false;
audio/volume/volume_ipc3.c:			cd->volume[i] = cd->tvolume[i];
audio/volume/volume_ipc3.c:		cd->ramp_finished = true;
audio/volume/volume_ipc3.c:	cd->vol = rmalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM, vol_size);
audio/volume/volume_ipc3.c:	if (!cd->vol) {
audio/volume/volume_ipc3.c:	cd->is_passthrough = false;
audio/volume/volume_ipc3.c:			cd->vol_min = VOL_MIN;
audio/volume/volume_ipc3.c:			cd->vol_min = vol->min_value;
audio/volume/volume_ipc3.c:			cd->vol_max = VOL_MAX;
audio/volume/volume_ipc3.c:			cd->vol_max = vol->max_value;
audio/volume/volume_ipc3.c:		cd->vol_ramp_range = vol->max_value - vol->min_value;
audio/volume/volume_ipc3.c:		cd->vol_min = VOL_MIN;
audio/volume/volume_ipc3.c:		cd->vol_max = VOL_MAX;
audio/volume/volume_ipc3.c:		cd->vol_ramp_range = 0;
audio/volume/volume_ipc3.c:		cd->volume[i]  =  MAX(MIN(cd->vol_max, VOL_ZERO_DB),
audio/volume/volume_ipc3.c:				      cd->vol_min);
audio/volume/volume_ipc3.c:		cd->tvolume[i] = cd->volume[i];
audio/volume/volume_ipc3.c:		cd->mvolume[i] = cd->volume[i];
audio/volume/volume_ipc3.c:		cd->muted[i] = false;
audio/volume/volume_ipc3.c:	cd->ramp_channel_counter = 1;
audio/volume/volume_ipc3.c:	switch (cd->ramp_type) {
audio/volume/volume_ipc3.c:		cd->ramp_type = vol->ramp;
audio/volume/volume_ipc3.c:		cd->initial_ramp = vol->initial_ramp;
audio/volume/volume_ipc3.c:		rfree(cd->vol);
audio/volume/volume_ipc3.c:	comp_info(dev, "volume_set_config() channel %d", cd->channels);
audio/volume/volume_ipc3.c:			if (cd->muted[ch]) {
audio/volume/volume_ipc3.c:				cd->mvolume[ch] = val;
audio/volume/volume_ipc3.c:		volume_set_ramp_channel_counter(dev, cd, cd->channels);
audio/volume/volume_ipc3.c:			cdata->chanv[j].value = cd->tvolume[j];
audio/volume/volume_ipc3.c:			cdata->chanv[j].value = !cd->muted[j];
audio/volume/volume_ipc4.c:	cd->scale_vol = vol_get_processing_function(dev, cd);
audio/volume/volume_ipc4.c:	cd->peak_regs.target_volume[channel] = target_volume;
audio/volume/volume_ipc4.c:	cd->peak_regs.peak_meter[channel] = 0;
audio/volume/volume_ipc4.c:	cd->peak_cnt = 0;
audio/volume/volume_ipc4.c:	cd->tvolume[channel] = target_volume;
audio/volume/volume_ipc4.c:	cd->rvolume[channel] = 0;
audio/volume/volume_ipc4.c:	cd->ramp_type = ipc4_curve_type_convert((enum ipc4_curve_type)curve_type);
audio/volume/volume_ipc4.c:	cd->ramp_finished = false;
audio/volume/volume_ipc4.c:	if (cd->ramp_type == SOF_VOLUME_WINDOWS_NO_FADE) {
audio/volume/volume_ipc4.c:		cd->initial_ramp = 0;
audio/volume/volume_ipc4.c:		cd->ramp_finished = true;
audio/volume/volume_ipc4.c:		cd->initial_ramp = Q_MULTSR_32X32((int64_t)curve_duration,
audio/volume/volume_ipc4.c:	cd->vol_min = VOL_MIN;
audio/volume/volume_ipc4.c:	cd->vol_max = VOL_MAX;
audio/volume/volume_ipc4.c:	cd->copy_gain = true;
audio/volume/volume_ipc4.c:	cd->vol = rmalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM, vol_size);
audio/volume/volume_ipc4.c:	if (!cd->vol) {
audio/volume/volume_ipc4.c:	cd->peak_vol = rmalloc(SOF_MEM_ZONE_RUNTIME, 0, SOF_MEM_CAPS_RAM, vol_size);
audio/volume/volume_ipc4.c:	if (!cd->peak_vol) {
audio/volume/volume_ipc4.c:		rfree(cd->vol);
audio/volume/volume_ipc4.c:		cd->muted[channel] = false;
audio/volume/volume_ipc4.c:	cd->mailbox_offset = offsetof(struct ipc4_fw_registers, peak_vol_regs);
audio/volume/volume_ipc4.c:	cd->mailbox_offset += instance_id * sizeof(struct ipc4_peak_volume_regs);
audio/volume/volume_ipc4.c:	cd->attenuation = 0;
audio/volume/volume_ipc4.c:	cd->is_passthrough = false;
audio/volume/volume_ipc4.c:	mailbox_sw_regs_write(cd->mailbox_offset, &regs, sizeof(regs));
audio/volume/volume_ipc4.c:	rfree(cd->peak_vol);
audio/volume/volume_ipc4.c:			if (cd->muted[i]) {
audio/volume/volume_ipc4.c:				cd->mvolume[i] = cdata.target_volume;
audio/volume/volume_ipc4.c:				volume_set_chan(mod, i, cd->tvolume[i], true);
audio/volume/volume_ipc4.c:		if (cd->muted[cdata.channel_id]) {
audio/volume/volume_ipc4.c:			cd->mvolume[cdata.channel_id] = cdata.target_volume;
audio/volume/volume_ipc4.c:					cd->tvolume[cdata.channel_id], true);
audio/volume/volume_ipc4.c:	cd->is_passthrough = false;
audio/volume/volume_ipc4.c:	cd->scale_vol = vol_get_processing_function(dev, cd);
audio/volume/volume_ipc4.c:	cd->attenuation = attenuation;
audio/volume/volume_ipc4.c:	cd->ramp_finished = false;
audio/volume/volume_ipc4.c:	cd->is_passthrough = false;
audio/volume/volume_ipc4.c:	cd->scale_vol = vol_get_processing_function(dev, cd);
audio/volume/volume_ipc4.c:		for (i = 0; i < cd->channels; i++) {
audio/volume/volume_ipc4.c:			uint32_t volume = cd->peak_regs.target_volume[i];
audio/volume/volume_ipc4.c:		*data_offset_size = sizeof(*cdata) * cd->channels;
audio/volume/volume_ipc4.c:	for (i = 0; i < cd->channels; i++)
audio/volume/volume_ipc4.c:		cd->peak_regs.current_volume[i] = cd->volume[i];
audio/volume/volume_ipc4.c:	cd->peak_cnt = 0;
audio/volume/volume_ipc4.c:	cd->peak_report_cnt = CONFIG_PEAK_METER_UPDATE_PERIOD * 1000 / mod->dev->period;
audio/volume/volume_ipc4.c:	if (cd->peak_report_cnt == 0)
audio/volume/volume_ipc4.c:		cd->peak_report_cnt = 1;
drivers/imx/esai.c:/* 889f6dcd-ddcd-4e05-aa5b-0d39f8bca961 */
idc/idc.c:		schedule_task(ipc_dev->cd->task, 0, ipc_dev->cd->period);
idc/idc.c:		schedule_task_cancel(ipc_dev->cd->task);
ipc/ipc-common.c:		if (icd->id == id && (type == icd->type || type == COMP_TYPE_ANY))
ipc/ipc-common.c:		if (icd->type != COMP_TYPE_COMPONENT)
ipc/ipc-common.c:		if (dev_comp_pipe_id(icd->cd) == pipeline_id) {
ipc/ipc-common.c:			struct list_item *buffer_list = comp_buffer_list(icd->cd, dir);
ipc/ipc-helper.c:	switch (icd->type) {
ipc/ipc-helper.c:		return dev_comp_pipe_id(icd->cd);
ipc/ipc-helper.c:		return icd->cb->pipeline_id;
ipc/ipc-helper.c:		return icd->pipeline->pipeline_id;
ipc/ipc-helper.c:		tr_err(&ipc_tr, "Unknown ipc component type %u", icd->type);
ipc/ipc-helper.c:	if (icd->core != ipc_pipe->core) {
ipc/ipc-helper.c:		tr_err(&ipc_tr, "ipc_pipeline_complete(): icd->core (%d) != ipc_pipe->core (%d) for pipeline scheduling component icd->id %d",
ipc/ipc-helper.c:		       icd->core, ipc_pipe->core, icd->id);
ipc/ipc-helper.c:	p->sched_comp = icd->cd;
ipc/ipc-helper.c:	if (!cpu_is_me(icd->core))
ipc/ipc-helper.c:		return ipc_process_on_core(icd->core, false);
ipc/ipc-helper.c:	if (icd->cd->state != COMP_STATE_READY) {
ipc/ipc-helper.c:		       comp_id, icd->cd->state);
ipc/ipc-helper.c:	if (!icd->cd->bsource_list.next || !icd->cd->bsink_list.next) {
ipc/ipc-helper.c:		       icd->id);
ipc/ipc-helper.c:	list_for_item_safe(clist, tmp, &icd->cd->bsource_list) {
ipc/ipc-helper.c:	list_for_item_safe(clist, tmp, &icd->cd->bsink_list) {
ipc/ipc-helper.c:	comp_free(icd->cd);
ipc/ipc-helper.c:	icd->cd = NULL;
ipc/ipc-helper.c:	list_item_del(&icd->list);
ipc/ipc3/dai.c:		if (icd->type != COMP_TYPE_COMPONENT)
ipc/ipc3/dai.c:		if (!cpu_is_me(icd->core)) {
ipc/ipc3/dai.c:			comp_on_core[icd->core] = true;
ipc/ipc3/dai.c:		if (dev_comp_type(icd->cd) == SOF_COMP_DAI ||
ipc/ipc3/dai.c:		    dev_comp_type(icd->cd) == SOF_COMP_SG_DAI) {
ipc/ipc3/dai.c:			ret = comp_dai_config(icd->cd, common_config, spec_config);
ipc/ipc3/handler.c:	if (!pcm_dev->cd->pipeline) {
ipc/ipc3/handler.c:	switch (pcm_dev->cd->pipeline->status) {
ipc/ipc3/handler.c:		pipe_dbg(pcm_dev->cd->pipeline,
ipc/ipc3/handler.c:	err = pipeline_params(pcm_dev->cd->pipeline, pcm_dev->cd,
ipc/ipc3/handler.c:			    pcm_dev->cd->pipeline->pipeline_id,
ipc/ipc3/handler.c:	err = pipeline_prepare(pcm_dev->cd->pipeline, pcm_dev->cd);
ipc/ipc3/handler.c:			    pcm_dev->cd->pipeline->pipeline_id,
ipc/ipc3/handler.c:	reply.posn_offset = pcm_dev->cd->pipeline->posn_offset;
ipc/ipc3/handler.c:	reset_err = pipeline_reset(pcm_dev->cd->pipeline, pcm_dev->cd);
ipc/ipc3/handler.c:			    pcm_dev->cd->pipeline->pipeline_id,
ipc/ipc3/handler.c:	if (!pcm_dev->cd->pipeline) {
ipc/ipc3/handler.c:	ret = pipeline_reset(pcm_dev->cd->pipeline, pcm_dev->cd);
ipc/ipc3/handler.c:	if (!pcm_dev->cd->pipeline) {
ipc/ipc3/handler.c:	pipeline_get_timestamp(pcm_dev->cd->pipeline, pcm_dev->cd, &posn);
ipc/ipc3/handler.c:	mailbox_stream_write(pcm_dev->cd->pipeline->posn_offset,
ipc/ipc3/handler.c:	if (!pcm_dev->cd->pipeline) {
ipc/ipc3/handler.c:	if (pipeline_is_timer_driven(pcm_dev->cd->pipeline)) {
ipc/ipc3/handler.c:		ret = pipeline_trigger(pcm_dev->cd->pipeline, pcm_dev->cd, cmd);
ipc/ipc3/handler.c:		ret = pipeline_trigger_run(pcm_dev->cd->pipeline, pcm_dev->cd, cmd);
ipc/ipc3/helper.c:		if (icd->type != type)
ipc/ipc3/helper.c:		if ((!cpu_is_me(icd->core)) && ignore_remote)
ipc/ipc3/helper.c:		if (icd->type != COMP_TYPE_COMPONENT)
ipc/ipc3/helper.c:		if (ibd->cb->sink == icd->cd) {
ipc/ipc3/helper.c:		if (ibd->cb->source == icd->cd) {
ipc/ipc3/helper.c:	icd->cd = cd;
ipc/ipc3/helper.c:	icd->type = COMP_TYPE_COMPONENT;
ipc/ipc3/helper.c:	icd->core = comp->core;
ipc/ipc3/helper.c:	icd->id = comp->id;
ipc/ipc3/helper.c:	list_item_append(&icd->list, &ipc->comp_list);
ipc/ipc4/dai.c:			if (!cd->gtw_cfg) {
ipc/ipc4/dai.c:			const struct sof_alh_configuration_blob *alh_blob = cd->gtw_cfg;
ipc/ipc4/handler.c:	if (!pcm_dev->cd->pipeline) {
ipc/ipc4/handler.c:	err = ipc4_pipeline_params(pcm_dev->cd->pipeline, pcm_dev->cd);
ipc/ipc4/handler.c:			    pcm_dev->cd->pipeline->pipeline_id,
ipc/ipc4/handler.c:			    pcm_dev->cd->pipeline->comp_id, err);
ipc/ipc4/handler.c:	err = pipeline_prepare(pcm_dev->cd->pipeline, pcm_dev->cd);
ipc/ipc4/handler.c:			    pcm_dev->cd->pipeline->pipeline_id,
ipc/ipc4/handler.c:			    pcm_dev->cd->pipeline->comp_id, err);
ipc/ipc4/handler.c:	reset_err = pipeline_reset(pcm_dev->cd->pipeline, pcm_dev->cd);
ipc/ipc4/handler.c:			    pcm_dev->cd->pipeline->pipeline_id,
ipc/ipc4/handler.c:			    pcm_dev->cd->pipeline->comp_id, reset_err);
ipc/ipc4/handler.c:		if (icd->type != COMP_TYPE_PIPELINE)
ipc/ipc4/handler.c:		if (icd->pipeline->status == COMP_STATE_ACTIVE)
ipc/ipc4/handler.c:	if (!ppl_icd->pipeline->source_comp->direction_set &&
ipc/ipc4/handler.c:	    ppl_icd->pipeline->sink_comp->direction_set) {
ipc/ipc4/handler.c:		ppl_icd->pipeline->source_comp->direction =
ipc/ipc4/handler.c:			ppl_icd->pipeline->sink_comp->direction;
ipc/ipc4/handler.c:		ppl_icd->pipeline->source_comp->direction_set = true;
ipc/ipc4/handler.c:	if (!ppl_icd->pipeline->sink_comp->direction_set &&
ipc/ipc4/handler.c:	    ppl_icd->pipeline->source_comp->direction_set) {
ipc/ipc4/handler.c:		ppl_icd->pipeline->sink_comp->direction =
ipc/ipc4/handler.c:			ppl_icd->pipeline->source_comp->direction;
ipc/ipc4/handler.c:		ppl_icd->pipeline->sink_comp->direction_set = true;
ipc/ipc4/handler.c:	if (ppl_icd->pipeline->source_comp->direction == SOF_IPC_STREAM_PLAYBACK)
ipc/ipc4/handler.c:		host_id = ppl_icd->pipeline->source_comp->ipc_config.id;
ipc/ipc4/handler.c:		host_id = ppl_icd->pipeline->sink_comp->ipc_config.id;
ipc/ipc4/handler.c:	status = ppl_icd->pipeline->status;
ipc/ipc4/handler.c:	tr_dbg(&ipc_tr, "pipeline %d: initial state: %d, cmd: %d", ppl_icd->id,
ipc/ipc4/handler.c:			tr_dbg(&ipc_tr, "pipeline %d: set params", ppl_icd->id);
ipc/ipc4/handler.c:				    ppl_icd->id, status);
ipc/ipc4/handler.c:			tr_dbg(&ipc_tr, "pipeline %d: reset from init", ppl_icd->id);
ipc/ipc4/handler.c:			ret = ipc4_pipeline_complete(ipc, ppl_icd->id, cmd);
ipc/ipc4/handler.c:				    ppl_icd->id, status);
ipc/ipc4/handler.c:			tr_dbg(&ipc_tr, "pipeline %d: pause from init", ppl_icd->id);
ipc/ipc4/handler.c:			ret = ipc4_pipeline_complete(ipc, ppl_icd->id, cmd);
ipc/ipc4/handler.c:			    ppl_icd->id, cmd);
ipc/ipc4/handler.c:	status = ppl_icd->pipeline->status;
ipc/ipc4/handler.c:	tr_dbg(&ipc_tr, "pipeline %d: initial state: %d, cmd: %d", ppl_icd->id,
ipc/ipc4/handler.c:				    ppl_icd->id, status);
ipc/ipc4/handler.c:			    ppl_icd->id, cmd);
ipc/ipc4/handler.c:	ret = pipeline_trigger(host->cd->pipeline, host->cd, cmd);
ipc/ipc4/handler.c:			    ppl_icd->id, cmd, ret);
ipc/ipc4/handler.c:		       ppl_icd->id, cmd);
ipc/ipc4/handler.c:		ret = pipeline_reset(host->cd->pipeline, host->cd);
ipc/ipc4/handler.c:			if (ppl_icd->core != idx)
ipc/ipc4/handler.c:			idx = ppl_icd->core;
ipc/ipc4/handler.c:		if (!cpu_is_me(ppl_icd->core)) {
ipc/ipc4/handler.c:					ppl_icd->core,
ipc/ipc4/handler.c:				return ipc4_process_on_core(ppl_icd->core, false);
ipc/ipc4/handler.c:		if (!cpu_is_me(ppl_icd->core)) {
ipc/ipc4/handler.c:					ppl_icd->core,
ipc/ipc4/handler.c:				return ipc4_process_on_core(ppl_icd->core, false);
ipc/ipc4/helper.c:		if (icd->type != type)
ipc/ipc4/helper.c:			if (icd->id == ppl_id)
ipc/ipc4/helper.c:			if ((!cpu_is_me(icd->core)) && ignore_remote)
ipc/ipc4/helper.c:		list_for_item_safe(list, _list, &icd->cd->bsink_list) {
ipc/ipc4/helper.c:			pipeline_disconnect(icd->cd, buffer, PPL_CONN_DIR_COMP_TO_BUFFER);
ipc/ipc4/helper.c:		list_for_item_safe(list, _list, &icd->cd->bsource_list) {
ipc/ipc4/helper.c:			pipeline_disconnect(icd->cd, buffer, PPL_CONN_DIR_BUFFER_TO_COMP);
ipc/ipc4/helper.c:		if (!cpu_is_me(icd->core))
ipc/ipc4/helper.c:			ret = ipc_comp_free_remote(icd->cd);
ipc/ipc4/helper.c:			ret = ipc_comp_free(ipc, icd->id);
ipc/ipc4/helper.c:			if (icd->cd != dev)
ipc/ipc4/helper.c:			list_item_del(&icd->list);
ipc/ipc4/helper.c:		if (icd->type != COMP_TYPE_COMPONENT)
ipc/ipc4/helper.c:		if (dev_comp_pipe_id(icd->cd) != ppl_id)
ipc/ipc4/helper.c:		if (icd->cd->direction_set)
ipc/ipc4/helper.c:		if (list_is_empty(&icd->cd->bsource_list))
ipc/ipc4/helper.c:		src_buf = list_first_item(&icd->cd->bsource_list, struct comp_buffer, sink_list);
ipc/ipc4/helper.c:			icd->cd->direction = src_buf->source->direction;
ipc/ipc4/helper.c:			icd->cd->direction_set = true;
ipc/ipc4/helper.c:	return icd ? icd->cd : NULL;
ipc/ipc4/helper.c:	icd->cd = dev;
ipc/ipc4/helper.c:	icd->type = COMP_TYPE_COMPONENT;
ipc/ipc4/helper.c:	icd->core = dev->ipc_config.core;
ipc/ipc4/helper.c:	icd->id = dev->ipc_config.id;
ipc/ipc4/helper.c:	tr_dbg(&ipc_tr, "ipc4_add_comp_dev add comp %x", icd->id);
ipc/ipc4/helper.c:	list_item_append(&icd->list, &ipc->comp_list);
lib/notifier.c:/* 1fb15a7a-83cd-4c2e-8b32-4da1b2adeeaf */
probe/probe.c:		list_for_item(source_list, &dev->cd->bsource_list) {
probe/probe.c:		list_for_item(sink_list, &dev->cd->bsink_list) {
samples/audio/detect_test.c:	ipc_msg_send(cd->msg, NULL, true);
samples/audio/detect_test.c:	ipc_msg_send(cd->msg, &cd->event, true);
samples/audio/detect_test.c:	cd->client_data.r_ptr = NULL;
samples/audio/detect_test.c:	cd->client_data.sink = NULL;
samples/audio/detect_test.c:	cd->client_data.id = 0; /**< TODO: acquire proper id from kpb */
samples/audio/detect_test.c:	cd->client_data.drain_req = (cd->drain_req != 0) ?
samples/audio/detect_test.c:				     cd->drain_req :
samples/audio/detect_test.c:				     cd->config.drain_req;
samples/audio/detect_test.c:	ams_helper_prepare_payload(dev, &ams_payload, cd->kpd_uuid_id,
samples/audio/detect_test.c:				   (uint8_t *)&cd->client_data,
samples/audio/detect_test.c:	comp_info(dev, "notify_kpb(), preamble: %u", cd->detect_preamble);
samples/audio/detect_test.c:	cd->client_data.r_ptr = NULL;
samples/audio/detect_test.c:	cd->client_data.sink = NULL;
samples/audio/detect_test.c:	cd->client_data.id = 0; /**< TODO: acquire proper id from kpb */
samples/audio/detect_test.c:	cd->client_data.drain_req = (cd->drain_req != 0) ?
samples/audio/detect_test.c:					 cd->drain_req :
samples/audio/detect_test.c:					 cd->config.drain_req;
samples/audio/detect_test.c:	cd->event_data.event_id = KPB_EVENT_BEGIN_DRAINING;
samples/audio/detect_test.c:	cd->event_data.client_data = &cd->client_data;
samples/audio/detect_test.c:		       NOTIFIER_TARGET_CORE_ALL_MASK, &cd->event_data,
samples/audio/detect_test.c:		       sizeof(cd->event_data));
samples/audio/detect_test.c:	uint16_t valid_bits = cd->sample_valid_bytes * 8;
samples/audio/detect_test.c:	const int32_t activation_threshold = cd->config.activation_threshold;
samples/audio/detect_test.c:	if (cd->config.load_mips) {
samples/audio/detect_test.c:		cycles_per_frame = (cd->config.load_mips * 1000000 * count)
samples/audio/detect_test.c:	for (sample = 0; sample < count && !cd->detected; ++sample) {
samples/audio/detect_test.c:			diff = abs(*(int32_t *)src) - abs(cd->activation);
samples/audio/detect_test.c:			       abs((int16_t)cd->activation);
samples/audio/detect_test.c:		diff >>= cd->config.activation_shift;
samples/audio/detect_test.c:		cd->activation += diff;
samples/audio/detect_test.c:		if (cd->detect_preamble >= cd->keyphrase_samples) {
samples/audio/detect_test.c:			if (cd->activation >= activation_threshold) {
samples/audio/detect_test.c:				/* The algorithm shall use cd->drain_req
samples/audio/detect_test.c:				cd->drain_req = 0;
samples/audio/detect_test.c:				cd->detected = 1;
samples/audio/detect_test.c:			++cd->detect_preamble;
samples/audio/detect_test.c:	ret = memcpy_s(&cd->config, sizeof(cd->config), cfg,
samples/audio/detect_test.c:	sample_width = cd->base_cfg.audio_fmt.depth;
samples/audio/detect_test.c:	sample_width = cd->config.sample_width;
samples/audio/detect_test.c:	if (!cd->config.activation_shift)
samples/audio/detect_test.c:		cd->config.activation_shift = ACTIVATION_DEFAULT_SHIFT;
samples/audio/detect_test.c:	if (!cd->config.activation_threshold) {
samples/audio/detect_test.c:		cd->config.activation_threshold = ret;
samples/audio/detect_test.c:	params->channels = cd->base_cfg.audio_fmt.channels_count;
samples/audio/detect_test.c:	params->rate = cd->base_cfg.audio_fmt.sampling_frequency;
samples/audio/detect_test.c:	params->sample_container_bytes = cd->base_cfg.audio_fmt.depth / 8;
samples/audio/detect_test.c:		cd->base_cfg.audio_fmt.valid_bit_depth / 8;
samples/audio/detect_test.c:	params->buffer_fmt = cd->base_cfg.audio_fmt.interleaving_style;
samples/audio/detect_test.c:	params->buffer.size = cd->base_cfg.ibs;
samples/audio/detect_test.c:	audio_stream_fmt_conversion(cd->base_cfg.audio_fmt.depth,
samples/audio/detect_test.c:				    cd->base_cfg.audio_fmt.valid_bit_depth,
samples/audio/detect_test.c:				    cd->base_cfg.audio_fmt.s_type);
samples/audio/detect_test.c:	ret = memcpy_s(data, cfg_size, &cd->config, cfg_size);
samples/audio/detect_test.c:		return ipc4_comp_data_blob_set(cd->model_handler,
samples/audio/detect_test.c:		*(struct ipc4_base_module_cfg *)value = cd->base_cfg;
samples/audio/detect_test.c:		ret = comp_data_blob_set_cmd(cd->model_handler, cdata);
samples/audio/detect_test.c:	bs = cd->config.size;
samples/audio/detect_test.c:	ret = memcpy_s(cdata->data->data, size, &cd->config, bs);
samples/audio/detect_test.c:		ret = comp_data_blob_get_cmd(cd->model_handler, cdata, size);
samples/audio/detect_test.c:	cd->detect_func = kwd_nn_detect_test;
samples/audio/detect_test.c:	cd->detect_func = default_detect_test;
samples/audio/detect_test.c:	cd->model_handler = comp_data_blob_handler_new(dev);
samples/audio/detect_test.c:	memcpy_s(&cd->base_cfg, sizeof(cd->base_cfg), base_cfg, sizeof(*base_cfg));
samples/audio/detect_test.c:	ret = comp_init_data_blob(cd->model_handler, INITIAL_MODEL_DATA_SIZE,
samples/audio/detect_test.c:	ipc_build_comp_event(&cd->event, dev->ipc_config.type, dev->ipc_config.id);
samples/audio/detect_test.c:	cd->event.event_type = SOF_CTRL_EVENT_KD;
samples/audio/detect_test.c:	cd->event.num_elems = 0;
samples/audio/detect_test.c:	cd->msg = ipc4_kd_notification_init(NOTIFICATION_DEFAULT_WORD_ID,
samples/audio/detect_test.c:	cd->msg = ipc_msg_init(cd->event.rhdr.hdr.cmd, sizeof(cd->event));
samples/audio/detect_test.c:	if (!cd->msg) {
samples/audio/detect_test.c:	cd->input = rballoc_align(0, SOF_MEM_CAPS_RAM,
samples/audio/detect_test.c:	if (!cd->input) {
samples/audio/detect_test.c:	bzero(cd->input, sizeof(int16_t) * KWD_NN_IN_BUFF_SIZE);
samples/audio/detect_test.c:	cd->input_size = 0;
samples/audio/detect_test.c:	comp_data_blob_handler_free(cd->model_handler);
samples/audio/detect_test.c:	ret = ams_helper_unregister_producer(dev, cd->kpd_uuid_id);
samples/audio/detect_test.c:	ipc_msg_free(cd->msg);
samples/audio/detect_test.c:	comp_data_blob_handler_free(cd->model_handler);
samples/audio/detect_test.c:	cd->sample_valid_bytes = params->sample_valid_bytes;
samples/audio/detect_test.c:	if (cd->config.preamble_time) {
samples/audio/detect_test.c:		cd->keyphrase_samples = cd->config.preamble_time *
samples/audio/detect_test.c:		cd->keyphrase_samples = KEYPHRASE_DEFAULT_PREAMBLE_LENGTH;
samples/audio/detect_test.c:	cd->kpd_uuid_id = AMS_INVALID_MSG_TYPE;
samples/audio/detect_test.c:	cd->config.activation_threshold = err;
samples/audio/detect_test.c:		cd->detect_preamble = 0;
samples/audio/detect_test.c:		cd->detected = 0;
samples/audio/detect_test.c:		cd->activation = 0;
samples/audio/detect_test.c:	cd->detect_func(dev, &source->stream, frames);
samples/audio/detect_test.c:	cd->activation = 0;
samples/audio/detect_test.c:	cd->detect_preamble = 0;
samples/audio/detect_test.c:	cd->detected = 0;
samples/audio/detect_test.c:	uint16_t valid_bits = cd->sample_valid_bytes * 8;
samples/audio/detect_test.c:	sample_width = cd->base_cfg.audio_fmt.depth;
samples/audio/detect_test.c:	sample_width = cd->config.sample_width;
samples/audio/detect_test.c:		cd->config.activation_threshold = ret;
samples/audio/detect_test.c:	cd->data_blob = comp_get_data_blob(cd->model_handler,
samples/audio/detect_test.c:					   &cd->data_blob_size,
samples/audio/detect_test.c:					   &cd->data_blob_crc);
samples/audio/detect_test.c:	ret = ams_helper_register_producer(dev, &cd->kpd_uuid_id,
samples/audio/detect_test.c:	return cd->sample_valid_bytes;
samples/audio/detect_test.c:	return cd->detected;
samples/audio/detect_test.c:	cd->detected = detected;
samples/audio/detect_test.c:	return cd->input;
samples/audio/detect_test.c:	return *((unsigned char *)cd->input + index);
samples/audio/detect_test.c:	return cd->input[index];
samples/audio/detect_test.c:	cd->input[index] = val;
samples/audio/detect_test.c:	return cd->input_size;
samples/audio/detect_test.c:	cd->input_size = input_size;
samples/audio/detect_test.c:	return cd->drain_req;
samples/audio/detect_test.c:	cd->drain_req = drain_req;
samples/audio/kwd_nn_detect_test.c:				/* The algorithm shall use cd->drain_req
trace/trace.c:	switch (icd->type) {
trace/trace.c:		return &icd->cd->tctx;
trace/trace.c:		return &icd->cb->tctx;
trace/trace.c:		return &icd->pipeline->tctx;
trace/trace.c:		       icd->type);
trace/trace.c:		correct_comp = comp_id == -1 || icd->id == comp_id; /* todo: icd->topo_id */
